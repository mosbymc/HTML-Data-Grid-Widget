<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>tests\common\qunit.js - Grid Widget</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Grid Widget" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/grid.html">grid</a></li>
                                <li><a href="../classes/Grid DOM element.html">Grid DOM element</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: tests\common\qunit.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
 * QUnit 1.22.0
 * https://qunitjs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2016-02-23T15:57Z
 */

(function( global ) {

    var QUnit = {};

    var Date = global.Date;
    var now = Date.now || function() {
            return new Date().getTime();
        };

    var setTimeout = global.setTimeout;
    var clearTimeout = global.clearTimeout;

// Store a local window from the global to allow direct references.
    var window = global.window;

    var defined = {
        document: window &amp;&amp; window.document !== undefined,
        setTimeout: setTimeout !== undefined,
        sessionStorage: (function() {
            var x = &quot;qunit-test-string&quot;;
            try {
                sessionStorage.setItem( x, x );
                sessionStorage.removeItem( x );
                return true;
            } catch ( e ) {
                return false;
            }
        }() )
    };

    var fileName = ( sourceFromStacktrace( 0 ) || &quot;&quot; ).replace( /(:\d+)+\)?/, &quot;&quot; ).replace( /.+\//, &quot;&quot; );
    var globalStartCalled = false;
    var runStarted = false;

    var toString = Object.prototype.toString,
        hasOwn = Object.prototype.hasOwnProperty;

// returns a new Array with the elements that are in a but not in b
    function diff( a, b ) {
        var i, j,
            result = a.slice();

        for ( i = 0; i &lt; result.length; i++ ) {
            for ( j = 0; j &lt; b.length; j++ ) {
                if ( result[ i ] === b[ j ] ) {
                    result.splice( i, 1 );
                    i--;
                    break;
                }
            }
        }
        return result;
    }

// from jquery.js
    function inArray( elem, array ) {
        if ( array.indexOf ) {
            return array.indexOf( elem );
        }

        for ( var i = 0, length = array.length; i &lt; length; i++ ) {
            if ( array[ i ] === elem ) {
                return i;
            }
        }

        return -1;
    }

    /**
     * Makes a clone of an object using only Array or Object as base,
     * and copies over the own enumerable properties.
     *
     * @param {Object} obj
     * @return {Object} New object with only the own properties (recursively).
     */
    function objectValues ( obj ) {
        var key, val,
            vals = QUnit.is( &quot;array&quot;, obj ) ? [] : {};
        for ( key in obj ) {
            if ( hasOwn.call( obj, key ) ) {
                val = obj[ key ];
                vals[ key ] = val === Object( val ) ? objectValues( val ) : val;
            }
        }
        return vals;
    }

    function extend( a, b, undefOnly ) {
        for ( var prop in b ) {
            if ( hasOwn.call( b, prop ) ) {

                // Avoid &quot;Member not found&quot; error in IE8 caused by messing with window.constructor
                // This block runs on every environment, so &#x60;global&#x60; is being used instead of &#x60;window&#x60;
                // to avoid errors on node.
                if ( prop !== &quot;constructor&quot; || a !== global ) {
                    if ( b[ prop ] === undefined ) {
                        delete a[ prop ];
                    } else if ( !( undefOnly &amp;&amp; typeof a[ prop ] !== &quot;undefined&quot; ) ) {
                        a[ prop ] = b[ prop ];
                    }
                }
            }
        }

        return a;
    }

    function objectType( obj ) {
        if ( typeof obj === &quot;undefined&quot; ) {
            return &quot;undefined&quot;;
        }

        // Consider: typeof null === object
        if ( obj === null ) {
            return &quot;null&quot;;
        }

        var match = toString.call( obj ).match( /^\[object\s(.*)\]$/ ),
            type = match &amp;&amp; match[ 1 ];

        switch ( type ) {
            case &quot;Number&quot;:
                if ( isNaN( obj ) ) {
                    return &quot;nan&quot;;
                }
                return &quot;number&quot;;
            case &quot;String&quot;:
            case &quot;Boolean&quot;:
            case &quot;Array&quot;:
            case &quot;Set&quot;:
            case &quot;Map&quot;:
            case &quot;Date&quot;:
            case &quot;RegExp&quot;:
            case &quot;Function&quot;:
            case &quot;Symbol&quot;:
                return type.toLowerCase();
        }
        if ( typeof obj === &quot;object&quot; ) {
            return &quot;object&quot;;
        }
    }

// Safe object type checking
    function is( type, obj ) {
        return QUnit.objectType( obj ) === type;
    }

    var getUrlParams = function() {
        var i, param, name, value;
        var urlParams = {};
        var location = window.location;
        var params = location.search.slice( 1 ).split( &quot;&amp;&quot; );
        var length = params.length;

        for ( i = 0; i &lt; length; i++ ) {
            if ( params[ i ] ) {
                param = params[ i ].split( &quot;=&quot; );
                name = decodeURIComponent( param[ 0 ] );

                // allow just a key to turn on a flag, e.g., test.html?noglobals
                value = param.length === 1 ||
                    decodeURIComponent( param.slice( 1 ).join( &quot;=&quot; ) ) ;
                if ( urlParams[ name ] ) {
                    urlParams[ name ] = [].concat( urlParams[ name ], value );
                } else {
                    urlParams[ name ] = value;
                }
            }
        }

        return urlParams;
    };

// Doesn&#x27;t support IE6 to IE9, it will return undefined on these browsers
// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack
    function extractStacktrace( e, offset ) {
        offset = offset === undefined ? 4 : offset;

        var stack, include, i;

        if ( e.stack ) {
            stack = e.stack.split( &quot;\n&quot; );
            if ( /^error$/i.test( stack[ 0 ] ) ) {
                stack.shift();
            }
            if ( fileName ) {
                include = [];
                for ( i = offset; i &lt; stack.length; i++ ) {
                    if ( stack[ i ].indexOf( fileName ) !== -1 ) {
                        break;
                    }
                    include.push( stack[ i ] );
                }
                if ( include.length ) {
                    return include.join( &quot;\n&quot; );
                }
            }
            return stack[ offset ];

            // Support: Safari &lt;=6 only
        } else if ( e.sourceURL ) {

            // exclude useless self-reference for generated Error objects
            if ( /qunit.js$/.test( e.sourceURL ) ) {
                return;
            }

            // for actual exceptions, this is useful
            return e.sourceURL + &quot;:&quot; + e.line;
        }
    }

    function sourceFromStacktrace( offset ) {
        var error = new Error();

        // Support: Safari &lt;=7 only, IE &lt;=10 - 11 only
        // Not all browsers generate the &#x60;stack&#x60; property for &#x60;new Error()&#x60;, see also #636
        if ( !error.stack ) {
            try {
                throw error;
            } catch ( err ) {
                error = err;
            }
        }

        return extractStacktrace( error, offset );
    }

    /**
     * Config object: Maintain internal state
     * Later exposed as QUnit.config
     * &#x60;config&#x60; initialized at top of scope
     */
    var config = {
        // The queue of tests to run
        queue: [],

        // block until document ready
        blocking: true,

        // by default, run previously failed tests first
        // very useful in combination with &quot;Hide passed tests&quot; checked
        reorder: true,

        // by default, modify document.title when suite is done
        altertitle: true,

        // HTML Reporter: collapse every test except the first failing test
        // If false, all failing tests will be expanded
        collapse: true,

        // by default, scroll to top of the page when suite is done
        scrolltop: true,

        // depth up-to which object will be dumped
        maxDepth: 5,

        // when enabled, all tests must call expect()
        requireExpects: false,

        // add checkboxes that are persisted in the query-string
        // when enabled, the id is set to &#x60;true&#x60; as a &#x60;QUnit.config&#x60; property
        urlConfig: [
            {
                id: &quot;hidepassed&quot;,
                label: &quot;Hide passed tests&quot;,
                tooltip: &quot;Only show tests and assertions that fail. Stored as query-strings.&quot;
            },
            {
                id: &quot;noglobals&quot;,
                label: &quot;Check for Globals&quot;,
                tooltip: &quot;Enabling this will test if any test introduces new properties on the &quot; +
                &quot;global object (&#x60;window&#x60; in Browsers). Stored as query-strings.&quot;
            },
            {
                id: &quot;notrycatch&quot;,
                label: &quot;No try-catch&quot;,
                tooltip: &quot;Enabling this will run tests outside of a try-catch block. Makes debugging &quot; +
                &quot;exceptions in IE reasonable. Stored as query-strings.&quot;
            }
        ],

        // Set of all modules.
        modules: [],

        // Stack of nested modules
        moduleStack: [],

        // The first unnamed module
        currentModule: {
            name: &quot;&quot;,
            tests: []
        },

        callbacks: {}
    };

    var urlParams = defined.document ? getUrlParams() : {};

// Push a loose unnamed module to the modules collection
    config.modules.push( config.currentModule );

    if ( urlParams.filter === true ) {
        delete urlParams.filter;
    }

// String search anywhere in moduleName+testName
    config.filter = urlParams.filter;

    config.testId = [];
    if ( urlParams.testId ) {
        // Ensure that urlParams.testId is an array
        urlParams.testId = decodeURIComponent( urlParams.testId ).split( &quot;,&quot; );
        for (var i = 0; i &lt; urlParams.testId.length; i++ ) {
            config.testId.push( urlParams.testId[ i ] );
        }
    }

    var loggingCallbacks = {};

// Register logging callbacks
    function registerLoggingCallbacks( obj ) {
        var i, l, key,
            callbackNames = [ &quot;begin&quot;, &quot;done&quot;, &quot;log&quot;, &quot;testStart&quot;, &quot;testDone&quot;,
                &quot;moduleStart&quot;, &quot;moduleDone&quot; ];

        function registerLoggingCallback( key ) {
            var loggingCallback = function( callback ) {
                if ( objectType( callback ) !== &quot;function&quot; ) {
                    throw new Error(
                        &quot;QUnit logging methods require a callback function as their first parameters.&quot;
                    );
                }

                config.callbacks[ key ].push( callback );
            };

            // DEPRECATED: This will be removed on QUnit 2.0.0+
            // Stores the registered functions allowing restoring
            // at verifyLoggingCallbacks() if modified
            loggingCallbacks[ key ] = loggingCallback;

            return loggingCallback;
        }

        for ( i = 0, l = callbackNames.length; i &lt; l; i++ ) {
            key = callbackNames[ i ];

            // Initialize key collection of logging callback
            if ( objectType( config.callbacks[ key ] ) === &quot;undefined&quot; ) {
                config.callbacks[ key ] = [];
            }

            obj[ key ] = registerLoggingCallback( key );
        }
    }

    function runLoggingCallbacks( key, args ) {
        var i, l, callbacks;

        callbacks = config.callbacks[ key ];
        for ( i = 0, l = callbacks.length; i &lt; l; i++ ) {
            callbacks[ i ]( args );
        }
    }

// DEPRECATED: This will be removed on 2.0.0+
// This function verifies if the loggingCallbacks were modified by the user
// If so, it will restore it, assign the given callback and print a console warning
    function verifyLoggingCallbacks() {
        var loggingCallback, userCallback;

        for ( loggingCallback in loggingCallbacks ) {
            if ( QUnit[ loggingCallback ] !== loggingCallbacks[ loggingCallback ] ) {

                userCallback = QUnit[ loggingCallback ];

                // Restore the callback function
                QUnit[ loggingCallback ] = loggingCallbacks[ loggingCallback ];

                // Assign the deprecated given callback
                QUnit[ loggingCallback ]( userCallback );

                if ( global.console &amp;&amp; global.console.warn ) {
                    global.console.warn(
                        &quot;QUnit.&quot; + loggingCallback + &quot; was replaced with a new value.\n&quot; +
                        &quot;Please, check out the documentation on how to apply logging callbacks.\n&quot; +
                        &quot;Reference: https://api.qunitjs.com/category/callbacks/&quot;
                    );
                }
            }
        }
    }

    ( function() {
        if ( !defined.document ) {
            return;
        }

        // &#x60;onErrorFnPrev&#x60; initialized at top of scope
        // Preserve other handlers
        var onErrorFnPrev = window.onerror;

        // Cover uncaught exceptions
        // Returning true will suppress the default browser handler,
        // returning false will let it run.
        window.onerror = function( error, filePath, linerNr ) {
            var ret = false;
            if ( onErrorFnPrev ) {
                ret = onErrorFnPrev( error, filePath, linerNr );
            }

            // Treat return value as window.onerror itself does,
            // Only do our handling if not suppressed.
            if ( ret !== true ) {
                if ( QUnit.config.current ) {
                    if ( QUnit.config.current.ignoreGlobalErrors ) {
                        return true;
                    }
                    QUnit.pushFailure( error, filePath + &quot;:&quot; + linerNr );
                } else {
                    QUnit.test( &quot;global failure&quot;, extend(function() {
                        QUnit.pushFailure( error, filePath + &quot;:&quot; + linerNr );
                    }, { validTest: true } ) );
                }
                return false;
            }

            return ret;
        };
    } )();

    QUnit.urlParams = urlParams;

// Figure out if we&#x27;re running the tests from a server or not
    QUnit.isLocal = !( defined.document &amp;&amp; window.location.protocol !== &quot;file:&quot; );

// Expose the current QUnit version
    QUnit.version = &quot;1.22.0&quot;;

    extend( QUnit, {

        // call on start of module test to prepend name to all tests
        module: function( name, testEnvironment, executeNow ) {
            var module, moduleFns;
            var currentModule = config.currentModule;

            if ( arguments.length === 2 ) {
                if ( testEnvironment instanceof Function ) {
                    executeNow = testEnvironment;
                    testEnvironment = undefined;
                }
            }

            // DEPRECATED: handles setup/teardown functions,
            // beforeEach and afterEach should be used instead
            if ( testEnvironment &amp;&amp; testEnvironment.setup ) {
                testEnvironment.beforeEach = testEnvironment.setup;
                delete testEnvironment.setup;
            }
            if ( testEnvironment &amp;&amp; testEnvironment.teardown ) {
                testEnvironment.afterEach = testEnvironment.teardown;
                delete testEnvironment.teardown;
            }

            module = createModule();

            moduleFns = {
                beforeEach: setHook( module, &quot;beforeEach&quot; ),
                afterEach: setHook( module, &quot;afterEach&quot; )
            };

            if ( executeNow instanceof Function ) {
                config.moduleStack.push( module );
                setCurrentModule( module );
                executeNow.call( module.testEnvironment, moduleFns );
                config.moduleStack.pop();
                module = module.parentModule || currentModule;
            }

            setCurrentModule( module );

            function createModule() {
                var parentModule = config.moduleStack.length ?
                    config.moduleStack.slice( -1 )[ 0 ] : null;
                var moduleName = parentModule !== null ?
                    [ parentModule.name, name ].join( &quot; &gt; &quot; ) : name;
                var module = {
                    name: moduleName,
                    parentModule: parentModule,
                    tests: []
                };

                var env = {};
                if ( parentModule ) {
                    extend( env, parentModule.testEnvironment );
                    delete env.beforeEach;
                    delete env.afterEach;
                }
                extend( env, testEnvironment );
                module.testEnvironment = env;

                config.modules.push( module );
                return module;
            }

            function setCurrentModule( module ) {
                config.currentModule = module;
            }

        },

        // DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.
        asyncTest: asyncTest,

        test: test,

        skip: skip,

        only: only,

        // DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.
        // In QUnit 2.0, invoking it will ONLY affect the &#x60;QUnit.config.autostart&#x60; blocking behavior.
        start: function( count ) {
            var globalStartAlreadyCalled = globalStartCalled;

            if ( !config.current ) {
                globalStartCalled = true;

                if ( runStarted ) {
                    throw new Error( &quot;Called start() outside of a test context while already started&quot; );
                } else if ( globalStartAlreadyCalled || count &gt; 1 ) {
                    throw new Error( &quot;Called start() outside of a test context too many times&quot; );
                } else if ( config.autostart ) {
                    throw new Error( &quot;Called start() outside of a test context when &quot; +
                        &quot;QUnit.config.autostart was true&quot; );
                } else if ( !config.pageLoaded ) {

                    // The page isn&#x27;t completely loaded yet, so bail out and let &#x60;QUnit.load&#x60; handle it
                    config.autostart = true;
                    return;
                }
            } else {

                // If a test is running, adjust its semaphore
                config.current.semaphore -= count || 1;

                // If semaphore is non-numeric, throw error
                if ( isNaN( config.current.semaphore ) ) {
                    config.current.semaphore = 0;

                    QUnit.pushFailure(
                        &quot;Called start() with a non-numeric decrement.&quot;,
                        sourceFromStacktrace( 2 )
                    );
                    return;
                }

                // Don&#x27;t start until equal number of stop-calls
                if ( config.current.semaphore &gt; 0 ) {
                    return;
                }

                // throw an Error if start is called more often than stop
                if ( config.current.semaphore &lt; 0 ) {
                    config.current.semaphore = 0;

                    QUnit.pushFailure(
                        &quot;Called start() while already started (test&#x27;s semaphore was 0 already)&quot;,
                        sourceFromStacktrace( 2 )
                    );
                    return;
                }
            }

            resumeProcessing();
        },

        // DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.
        stop: function( count ) {

            // If there isn&#x27;t a test running, don&#x27;t allow QUnit.stop() to be called
            if ( !config.current ) {
                throw new Error( &quot;Called stop() outside of a test context&quot; );
            }

            // If a test is running, adjust its semaphore
            config.current.semaphore += count || 1;

            pauseProcessing();
        },

        config: config,

        is: is,

        objectType: objectType,

        extend: extend,

        load: function() {
            config.pageLoaded = true;

            // Initialize the configuration options
            extend( config, {
                stats: { all: 0, bad: 0 },
                moduleStats: { all: 0, bad: 0 },
                started: 0,
                updateRate: 1000,
                autostart: true,
                filter: &quot;&quot;
            }, true );

            config.blocking = false;

            if ( config.autostart ) {
                resumeProcessing();
            }
        },

        stack: function( offset ) {
            offset = ( offset || 0 ) + 2;
            return sourceFromStacktrace( offset );
        }
    });

    registerLoggingCallbacks( QUnit );

    function begin() {
        var i, l,
            modulesLog = [];

        // If the test run hasn&#x27;t officially begun yet
        if ( !config.started ) {

            // Record the time of the test run&#x27;s beginning
            config.started = now();

            verifyLoggingCallbacks();

            // Delete the loose unnamed module if unused.
            if ( config.modules[ 0 ].name === &quot;&quot; &amp;&amp; config.modules[ 0 ].tests.length === 0 ) {
                config.modules.shift();
            }

            // Avoid unnecessary information by not logging modules&#x27; test environments
            for ( i = 0, l = config.modules.length; i &lt; l; i++ ) {
                modulesLog.push({
                    name: config.modules[ i ].name,
                    tests: config.modules[ i ].tests
                });
            }

            // The test run is officially beginning now
            runLoggingCallbacks( &quot;begin&quot;, {
                totalTests: Test.count,
                modules: modulesLog
            });
        }

        config.blocking = false;
        process( true );
    }

    function process( last ) {
        function next() {
            process( last );
        }
        var start = now();
        config.depth = ( config.depth || 0 ) + 1;

        while ( config.queue.length &amp;&amp; !config.blocking ) {
            if ( !defined.setTimeout || config.updateRate &lt;= 0 ||
                ( ( now() - start ) &lt; config.updateRate ) ) {
                if ( config.current ) {

                    // Reset async tracking for each phase of the Test lifecycle
                    config.current.usedAsync = false;
                }
                config.queue.shift()();
            } else {
                setTimeout( next, 13 );
                break;
            }
        }
        config.depth--;
        if ( last &amp;&amp; !config.blocking &amp;&amp; !config.queue.length &amp;&amp; config.depth === 0 ) {
            done();
        }
    }

    function pauseProcessing() {
        config.blocking = true;

        if ( config.testTimeout &amp;&amp; defined.setTimeout ) {
            clearTimeout( config.timeout );
            config.timeout = setTimeout(function() {
                if ( config.current ) {
                    config.current.semaphore = 0;
                    QUnit.pushFailure( &quot;Test timed out&quot;, sourceFromStacktrace( 2 ) );
                } else {
                    throw new Error( &quot;Test timed out&quot; );
                }
                resumeProcessing();
            }, config.testTimeout );
        }
    }

    function resumeProcessing() {
        runStarted = true;

        // A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)
        if ( defined.setTimeout ) {
            setTimeout(function() {
                if ( config.current &amp;&amp; config.current.semaphore &gt; 0 ) {
                    return;
                }
                if ( config.timeout ) {
                    clearTimeout( config.timeout );
                }

                begin();
            }, 13 );
        } else {
            begin();
        }
    }

    function done() {
        var runtime, passed;

        config.autorun = true;

        // Log the last module results
        if ( config.previousModule ) {
            runLoggingCallbacks( &quot;moduleDone&quot;, {
                name: config.previousModule.name,
                tests: config.previousModule.tests,
                failed: config.moduleStats.bad,
                passed: config.moduleStats.all - config.moduleStats.bad,
                total: config.moduleStats.all,
                runtime: now() - config.moduleStats.started
            });
        }
        delete config.previousModule;

        runtime = now() - config.started;
        passed = config.stats.all - config.stats.bad;

        runLoggingCallbacks( &quot;done&quot;, {
            failed: config.stats.bad,
            passed: passed,
            total: config.stats.all,
            runtime: runtime
        });
    }

    function setHook( module, hookName ) {
        if ( module.testEnvironment === undefined ) {
            module.testEnvironment = {};
        }

        return function( callback ) {
            module.testEnvironment[ hookName ] = callback;
        };
    }

    var focused = false;
    var priorityCount = 0;

    function Test( settings ) {
        var i, l;

        ++Test.count;

        extend( this, settings );
        this.assertions = [];
        this.semaphore = 0;
        this.usedAsync = false;
        this.module = config.currentModule;
        this.stack = sourceFromStacktrace( 3 );

        // Register unique strings
        for ( i = 0, l = this.module.tests; i &lt; l.length; i++ ) {
            if ( this.module.tests[ i ].name === this.testName ) {
                this.testName += &quot; &quot;;
            }
        }

        this.testId = generateHash( this.module.name, this.testName );

        this.module.tests.push({
            name: this.testName,
            testId: this.testId
        });

        if ( settings.skip ) {

            // Skipped tests will fully ignore any sent callback
            this.callback = function() {};
            this.async = false;
            this.expected = 0;
        } else {
            this.assert = new Assert( this );
        }
    }

    Test.count = 0;

    Test.prototype = {
        before: function() {
            if (

                // Emit moduleStart when we&#x27;re switching from one module to another
            this.module !== config.previousModule ||

                // They could be equal (both undefined) but if the previousModule property doesn&#x27;t
                // yet exist it means this is the first test in a suite that isn&#x27;t wrapped in a
                // module, in which case we&#x27;ll just emit a moduleStart event for &#x27;undefined&#x27;.
                // Without this, reporters can get testStart before moduleStart  which is a problem.
            !hasOwn.call( config, &quot;previousModule&quot; )
            ) {
                if ( hasOwn.call( config, &quot;previousModule&quot; ) ) {
                    runLoggingCallbacks( &quot;moduleDone&quot;, {
                        name: config.previousModule.name,
                        tests: config.previousModule.tests,
                        failed: config.moduleStats.bad,
                        passed: config.moduleStats.all - config.moduleStats.bad,
                        total: config.moduleStats.all,
                        runtime: now() - config.moduleStats.started
                    });
                }
                config.previousModule = this.module;
                config.moduleStats = { all: 0, bad: 0, started: now() };
                runLoggingCallbacks( &quot;moduleStart&quot;, {
                    name: this.module.name,
                    tests: this.module.tests
                });
            }

            config.current = this;

            if ( this.module.testEnvironment ) {
                delete this.module.testEnvironment.beforeEach;
                delete this.module.testEnvironment.afterEach;
            }
            this.testEnvironment = extend( {}, this.module.testEnvironment );

            this.started = now();
            runLoggingCallbacks( &quot;testStart&quot;, {
                name: this.testName,
                module: this.module.name,
                testId: this.testId
            });

            if ( !config.pollution ) {
                saveGlobal();
            }
        },

        run: function() {
            var promise;

            config.current = this;

            if ( this.async ) {
                QUnit.stop();
            }

            this.callbackStarted = now();

            if ( config.notrycatch ) {
                runTest( this );
                return;
            }

            try {
                runTest( this );
            } catch ( e ) {
                this.pushFailure( &quot;Died on test #&quot; + ( this.assertions.length + 1 ) + &quot; &quot; +
                    this.stack + &quot;: &quot; + ( e.message || e ), extractStacktrace( e, 0 ) );

                // else next test will carry the responsibility
                saveGlobal();

                // Restart the tests if they&#x27;re blocking
                if ( config.blocking ) {
                    QUnit.start();
                }
            }

            function runTest( test ) {
                promise = test.callback.call( test.testEnvironment, test.assert );
                test.resolvePromise( promise );
            }
        },

        after: function() {
            checkPollution();
        },

        queueHook: function( hook, hookName ) {
            var promise,
                test = this;
            return function runHook() {
                config.current = test;
                if ( config.notrycatch ) {
                    callHook();
                    return;
                }
                try {
                    callHook();
                } catch ( error ) {
                    test.pushFailure( hookName + &quot; failed on &quot; + test.testName + &quot;: &quot; +
                        ( error.message || error ), extractStacktrace( error, 0 ) );
                }

                function callHook() {
                    promise = hook.call( test.testEnvironment, test.assert );
                    test.resolvePromise( promise, hookName );
                }
            };
        },

        // Currently only used for module level hooks, can be used to add global level ones
        hooks: function( handler ) {
            var hooks = [];

            function processHooks( test, module ) {
                if ( module.parentModule ) {
                    processHooks( test, module.parentModule );
                }
                if ( module.testEnvironment &amp;&amp;
                    QUnit.objectType( module.testEnvironment[ handler ] ) === &quot;function&quot; ) {
                    hooks.push( test.queueHook( module.testEnvironment[ handler ], handler ) );
                }
            }

            // Hooks are ignored on skipped tests
            if ( !this.skip ) {
                processHooks( this, this.module );
            }
            return hooks;
        },

        finish: function() {
            config.current = this;
            if ( config.requireExpects &amp;&amp; this.expected === null ) {
                this.pushFailure( &quot;Expected number of assertions to be defined, but expect() was &quot; +
                    &quot;not called.&quot;, this.stack );
            } else if ( this.expected !== null &amp;&amp; this.expected !== this.assertions.length ) {
                this.pushFailure( &quot;Expected &quot; + this.expected + &quot; assertions, but &quot; +
                    this.assertions.length + &quot; were run&quot;, this.stack );
            } else if ( this.expected === null &amp;&amp; !this.assertions.length ) {
                this.pushFailure( &quot;Expected at least one assertion, but none were run - call &quot; +
                    &quot;expect(0) to accept zero assertions.&quot;, this.stack );
            }

            var i,
                bad = 0;

            this.runtime = now() - this.started;
            config.stats.all += this.assertions.length;
            config.moduleStats.all += this.assertions.length;

            for ( i = 0; i &lt; this.assertions.length; i++ ) {
                if ( !this.assertions[ i ].result ) {
                    bad++;
                    config.stats.bad++;
                    config.moduleStats.bad++;
                }
            }

            runLoggingCallbacks( &quot;testDone&quot;, {
                name: this.testName,
                module: this.module.name,
                skipped: !!this.skip,
                failed: bad,
                passed: this.assertions.length - bad,
                total: this.assertions.length,
                runtime: this.runtime,

                // HTML Reporter use
                assertions: this.assertions,
                testId: this.testId,

                // Source of Test
                source: this.stack,

                // DEPRECATED: this property will be removed in 2.0.0, use runtime instead
                duration: this.runtime
            });

            // QUnit.reset() is deprecated and will be replaced for a new
            // fixture reset function on QUnit 2.0/2.1.
            // It&#x27;s still called here for backwards compatibility handling
            QUnit.reset();

            config.current = undefined;
        },

        queue: function() {
            var priority,
                test = this;

            if ( !this.valid() ) {
                return;
            }

            function run() {

                // each of these can by async
                synchronize([
                    function() {
                        test.before();
                    },

                    test.hooks( &quot;beforeEach&quot; ),
                    function() {
                        test.run();
                    },

                    test.hooks( &quot;afterEach&quot; ).reverse(),

                    function() {
                        test.after();
                    },
                    function() {
                        test.finish();
                    }
                ]);
            }

            // Prioritize previously failed tests, detected from sessionStorage
            priority = QUnit.config.reorder &amp;&amp; defined.sessionStorage &amp;&amp;
                +sessionStorage.getItem( &quot;qunit-test-&quot; + this.module.name + &quot;-&quot; + this.testName );

            return synchronize( run, priority );
        },

        pushResult: function( resultInfo ) {

            // resultInfo = { result, actual, expected, message, negative }
            var source,
                details = {
                    module: this.module.name,
                    name: this.testName,
                    result: resultInfo.result,
                    message: resultInfo.message,
                    actual: resultInfo.actual,
                    expected: resultInfo.expected,
                    testId: this.testId,
                    negative: resultInfo.negative || false,
                    runtime: now() - this.started
                };

            if ( !resultInfo.result ) {
                source = sourceFromStacktrace();

                if ( source ) {
                    details.source = source;
                }
            }

            runLoggingCallbacks( &quot;log&quot;, details );

            this.assertions.push({
                result: !!resultInfo.result,
                message: resultInfo.message
            });
        },

        pushFailure: function( message, source, actual ) {
            if ( !( this instanceof Test ) ) {
                throw new Error( &quot;pushFailure() assertion outside test context, was &quot; +
                    sourceFromStacktrace( 2 ) );
            }

            var details = {
                module: this.module.name,
                name: this.testName,
                result: false,
                message: message || &quot;error&quot;,
                actual: actual || null,
                testId: this.testId,
                runtime: now() - this.started
            };

            if ( source ) {
                details.source = source;
            }

            runLoggingCallbacks( &quot;log&quot;, details );

            this.assertions.push({
                result: false,
                message: message
            });
        },

        resolvePromise: function( promise, phase ) {
            var then, message,
                test = this;
            if ( promise != null ) {
                then = promise.then;
                if ( QUnit.objectType( then ) === &quot;function&quot; ) {
                    QUnit.stop();
                    then.call(
                        promise,
                        function() { QUnit.start(); },
                        function( error ) {
                            message = &quot;Promise rejected &quot; +
                                ( !phase ? &quot;during&quot; : phase.replace( /Each$/, &quot;&quot; ) ) +
                                &quot; &quot; + test.testName + &quot;: &quot; + ( error.message || error );
                            test.pushFailure( message, extractStacktrace( error, 0 ) );

                            // else next test will carry the responsibility
                            saveGlobal();

                            // Unblock
                            QUnit.start();
                        }
                    );
                }
            }
        },

        valid: function() {
            var filter = config.filter,
                regexFilter = /^(!?)\/([\w\W]*)\/(i?$)/.exec( filter ),
                module = QUnit.urlParams.module &amp;&amp; QUnit.urlParams.module.toLowerCase(),
                fullName = ( this.module.name + &quot;: &quot; + this.testName );

            function testInModuleChain( testModule ) {
                var testModuleName = testModule.name ? testModule.name.toLowerCase() : null;
                if ( testModuleName === module ) {
                    return true;
                } else if ( testModule.parentModule ) {
                    return testInModuleChain( testModule.parentModule );
                } else {
                    return false;
                }
            }

            // Internally-generated tests are always valid
            if ( this.callback &amp;&amp; this.callback.validTest ) {
                return true;
            }

            if ( config.testId.length &gt; 0 &amp;&amp; inArray( this.testId, config.testId ) &lt; 0 ) {
                return false;
            }

            if ( module &amp;&amp; !testInModuleChain( this.module ) ) {
                return false;
            }

            if ( !filter ) {
                return true;
            }

            return regexFilter ?
                this.regexFilter( !!regexFilter[1], regexFilter[2], regexFilter[3], fullName ) :
                this.stringFilter( filter, fullName );
        },

        regexFilter: function( exclude, pattern, flags, fullName ) {
            var regex = new RegExp( pattern, flags );
            var match = regex.test( fullName );

            return match !== exclude;
        },

        stringFilter: function( filter, fullName ) {
            filter = filter.toLowerCase();
            fullName = fullName.toLowerCase();

            var include = filter.charAt( 0 ) !== &quot;!&quot;;
            if ( !include ) {
                filter = filter.slice( 1 );
            }

            // If the filter matches, we need to honour include
            if ( fullName.indexOf( filter ) !== -1 ) {
                return include;
            }

            // Otherwise, do the opposite
            return !include;
        }
    };

// Resets the test setup. Useful for tests that modify the DOM.
    /*
     DEPRECATED: Use multiple tests instead of resetting inside a test.
     Use testStart or testDone for custom cleanup.
     This method will throw an error in 2.0, and will be removed in 2.1
     */
    QUnit.reset = function() {

        // Return on non-browser environments
        // This is necessary to not break on node tests
        if ( !defined.document ) {
            return;
        }

        var fixture = defined.document &amp;&amp; document.getElementById &amp;&amp;
            document.getElementById( &quot;qunit-fixture&quot; );

        if ( fixture ) {
            fixture.innerHTML = config.fixture;
        }
    };

    QUnit.pushFailure = function() {
        if ( !QUnit.config.current ) {
            throw new Error( &quot;pushFailure() assertion outside test context, in &quot; +
                sourceFromStacktrace( 2 ) );
        }

        // Gets current test obj
        var currentTest = QUnit.config.current;

        return currentTest.pushFailure.apply( currentTest, arguments );
    };

// Based on Java&#x27;s String.hashCode, a simple but not
// rigorously collision resistant hashing function
    function generateHash( module, testName ) {
        var hex,
            i = 0,
            hash = 0,
            str = module + &quot;\x1C&quot; + testName,
            len = str.length;

        for ( ; i &lt; len; i++ ) {
            hash  = ( ( hash &lt;&lt; 5 ) - hash ) + str.charCodeAt( i );
            hash |= 0;
        }

        // Convert the possibly negative integer hash code into an 8 character hex string, which isn&#x27;t
        // strictly necessary but increases user understanding that the id is a SHA-like hash
        hex = ( 0x100000000 + hash ).toString( 16 );
        if ( hex.length &lt; 8 ) {
            hex = &quot;0000000&quot; + hex;
        }

        return hex.slice( -8 );
    }

    function synchronize( callback, priority ) {
        var last = !priority;

        if ( QUnit.objectType( callback ) === &quot;array&quot; ) {
            while ( callback.length ) {
                synchronize( callback.shift() );
            }
            return;
        }

        if ( priority ) {
            config.queue.splice( priorityCount++, 0, callback );
        } else {
            config.queue.push( callback );
        }

        if ( config.autorun &amp;&amp; !config.blocking ) {
            process( last );
        }
    }

    function saveGlobal() {
        config.pollution = [];

        if ( config.noglobals ) {
            for ( var key in global ) {
                if ( hasOwn.call( global, key ) ) {

                    // in Opera sometimes DOM element ids show up here, ignore them
                    if ( /^qunit-test-output/.test( key ) ) {
                        continue;
                    }
                    config.pollution.push( key );
                }
            }
        }
    }

    function checkPollution() {
        var newGlobals,
            deletedGlobals,
            old = config.pollution;

        saveGlobal();

        newGlobals = diff( config.pollution, old );
        if ( newGlobals.length &gt; 0 ) {
            QUnit.pushFailure( &quot;Introduced global variable(s): &quot; + newGlobals.join( &quot;, &quot; ) );
        }

        deletedGlobals = diff( old, config.pollution );
        if ( deletedGlobals.length &gt; 0 ) {
            QUnit.pushFailure( &quot;Deleted global variable(s): &quot; + deletedGlobals.join( &quot;, &quot; ) );
        }
    }

// Will be exposed as QUnit.asyncTest
    function asyncTest( testName, expected, callback ) {
        if ( arguments.length === 2 ) {
            callback = expected;
            expected = null;
        }

        QUnit.test( testName, expected, callback, true );
    }

// Will be exposed as QUnit.test
    function test( testName, expected, callback, async ) {
        if ( focused )  { return; }

        var newTest;

        if ( arguments.length === 2 ) {
            callback = expected;
            expected = null;
        }

        newTest = new Test({
            testName: testName,
            expected: expected,
            async: async,
            callback: callback
        });

        newTest.queue();
    }

// Will be exposed as QUnit.skip
    function skip( testName ) {
        if ( focused )  { return; }

        var test = new Test({
            testName: testName,
            skip: true
        });

        test.queue();
    }

// Will be exposed as QUnit.only
    function only( testName, expected, callback, async ) {
        var newTest;

        if ( focused )  { return; }

        QUnit.config.queue.length = 0;
        focused = true;

        if ( arguments.length === 2 ) {
            callback = expected;
            expected = null;
        }

        newTest = new Test({
            testName: testName,
            expected: expected,
            async: async,
            callback: callback
        });

        newTest.queue();
    }

    function Assert( testContext ) {
        this.test = testContext;
    }

// Assert helpers
    QUnit.assert = Assert.prototype = {

        // Specify the number of expected assertions to guarantee that failed test
        // (no assertions are run at all) don&#x27;t slip through.
        expect: function( asserts ) {
            if ( arguments.length === 1 ) {
                this.test.expected = asserts;
            } else {
                return this.test.expected;
            }
        },

        // Increment this Test&#x27;s semaphore counter, then return a function that
        // decrements that counter a maximum of once.
        async: function( count ) {
            var test = this.test,
                popped = false,
                acceptCallCount = count;

            if ( typeof acceptCallCount === &quot;undefined&quot; ) {
                acceptCallCount = 1;
            }

            test.semaphore += 1;
            test.usedAsync = true;
            pauseProcessing();

            return function done() {

                if ( popped ) {
                    test.pushFailure( &quot;Too many calls to the &#x60;assert.async&#x60; callback&quot;,
                        sourceFromStacktrace( 2 ) );
                    return;
                }
                acceptCallCount -= 1;
                if ( acceptCallCount &gt; 0 ) {
                    return;
                }

                test.semaphore -= 1;
                popped = true;
                resumeProcessing();
            };
        },

        // Exports test.push() to the user API
        // Alias of pushResult.
        push: function( result, actual, expected, message, negative ) {
            var currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;
            return currentAssert.pushResult( {
                result: result,
                actual: actual,
                expected: expected,
                message: message,
                negative: negative
            } );
        },

        pushResult: function( resultInfo ) {

            // resultInfo = { result, actual, expected, message, negative }
            var assert = this,
                currentTest = ( assert instanceof Assert &amp;&amp; assert.test ) || QUnit.config.current;

            // Backwards compatibility fix.
            // Allows the direct use of global exported assertions and QUnit.assert.*
            // Although, it&#x27;s use is not recommended as it can leak assertions
            // to other tests from async tests, because we only get a reference to the current test,
            // not exactly the test where assertion were intended to be called.
            if ( !currentTest ) {
                throw new Error( &quot;assertion outside test context, in &quot; + sourceFromStacktrace( 2 ) );
            }

            if ( currentTest.usedAsync === true &amp;&amp; currentTest.semaphore === 0 ) {
                currentTest.pushFailure( &quot;Assertion after the final &#x60;assert.async&#x60; was resolved&quot;,
                    sourceFromStacktrace( 2 ) );

                // Allow this assertion to continue running anyway...
            }

            if ( !( assert instanceof Assert ) ) {
                assert = currentTest.assert;
            }

            return assert.test.pushResult( resultInfo );
        },

        ok: function( result, message ) {
            message = message || ( result ? &quot;okay&quot; : &quot;failed, expected argument to be truthy, was: &quot; +
                QUnit.dump.parse( result ) );
            this.pushResult( {
                result: !!result,
                actual: result,
                expected: true,
                message: message
            } );
        },

        notOk: function( result, message ) {
            message = message || ( !result ? &quot;okay&quot; : &quot;failed, expected argument to be falsy, was: &quot; +
                QUnit.dump.parse( result ) );
            this.pushResult( {
                result: !result,
                actual: result,
                expected: false,
                message: message
            } );
        },

        equal: function( actual, expected, message ) {
            /*jshint eqeqeq:false */
            this.pushResult( {
                result: expected == actual,
                actual: actual,
                expected: expected,
                message: message
            } );
        },

        notEqual: function( actual, expected, message ) {
            /*jshint eqeqeq:false */
            this.pushResult( {
                result: expected != actual,
                actual: actual,
                expected: expected,
                message: message,
                negative: true
            } );
        },

        propEqual: function( actual, expected, message ) {
            actual = objectValues( actual );
            expected = objectValues( expected );
            this.pushResult( {
                result: QUnit.equiv( actual, expected ),
                actual: actual,
                expected: expected,
                message: message
            } );
        },

        notPropEqual: function( actual, expected, message ) {
            actual = objectValues( actual );
            expected = objectValues( expected );
            this.pushResult( {
                result: !QUnit.equiv( actual, expected ),
                actual: actual,
                expected: expected,
                message: message,
                negative: true
            } );
        },

        deepEqual: function( actual, expected, message ) {
            this.pushResult( {
                result: QUnit.equiv( actual, expected ),
                actual: actual,
                expected: expected,
                message: message
            } );
        },

        notDeepEqual: function( actual, expected, message ) {
            this.pushResult( {
                result: !QUnit.equiv( actual, expected ),
                actual: actual,
                expected: expected,
                message: message,
                negative: true
            } );
        },

        strictEqual: function( actual, expected, message ) {
            this.pushResult( {
                result: expected === actual,
                actual: actual,
                expected: expected,
                message: message
            } );
        },

        notStrictEqual: function( actual, expected, message ) {
            this.pushResult( {
                result: expected !== actual,
                actual: actual,
                expected: expected,
                message: message,
                negative: true
            } );
        },

        &quot;throws&quot;: function( block, expected, message ) {
            var actual, expectedType,
                expectedOutput = expected,
                ok = false,
                currentTest = ( this instanceof Assert &amp;&amp; this.test ) || QUnit.config.current;

            // &#x27;expected&#x27; is optional unless doing string comparison
            if ( message == null &amp;&amp; typeof expected === &quot;string&quot; ) {
                message = expected;
                expected = null;
            }

            currentTest.ignoreGlobalErrors = true;
            try {
                block.call( currentTest.testEnvironment );
            } catch (e) {
                actual = e;
            }
            currentTest.ignoreGlobalErrors = false;

            if ( actual ) {
                expectedType = QUnit.objectType( expected );

                // we don&#x27;t want to validate thrown error
                if ( !expected ) {
                    ok = true;
                    expectedOutput = null;

                    // expected is a regexp
                } else if ( expectedType === &quot;regexp&quot; ) {
                    ok = expected.test( errorString( actual ) );

                    // expected is a string
                } else if ( expectedType === &quot;string&quot; ) {
                    ok = expected === errorString( actual );

                    // expected is a constructor, maybe an Error constructor
                } else if ( expectedType === &quot;function&quot; &amp;&amp; actual instanceof expected ) {
                    ok = true;

                    // expected is an Error object
                } else if ( expectedType === &quot;object&quot; ) {
                    ok = actual instanceof expected.constructor &amp;&amp;
                        actual.name === expected.name &amp;&amp;
                        actual.message === expected.message;

                    // expected is a validation function which returns true if validation passed
                } else if ( expectedType === &quot;function&quot; &amp;&amp; expected.call( {}, actual ) === true ) {
                    expectedOutput = null;
                    ok = true;
                }
            }

            currentTest.assert.pushResult( {
                result: ok,
                actual: actual,
                expected: expectedOutput,
                message: message
            } );
        }
    };

// Provide an alternative to assert.throws(), for environments that consider throws a reserved word
// Known to us are: Closure Compiler, Narwhal
    (function() {
        /*jshint sub:true */
        Assert.prototype.raises = Assert.prototype[ &quot;throws&quot; ];
    }());

    function errorString( error ) {
        var name, message,
            resultErrorString = error.toString();
        if ( resultErrorString.substring( 0, 7 ) === &quot;[object&quot; ) {
            name = error.name ? error.name.toString() : &quot;Error&quot;;
            message = error.message ? error.message.toString() : &quot;&quot;;
            if ( name &amp;&amp; message ) {
                return name + &quot;: &quot; + message;
            } else if ( name ) {
                return name;
            } else if ( message ) {
                return message;
            } else {
                return &quot;Error&quot;;
            }
        } else {
            return resultErrorString;
        }
    }

// Test for equality any JavaScript type.
// Author: Philippe Rathé &lt;prathe@gmail.com&gt;
    QUnit.equiv = (function() {

        // Stack to decide between skip/abort functions
        var callers = [];

        // Stack to avoiding loops from circular referencing
        var parents = [];
        var parentsB = [];

        var getProto = Object.getPrototypeOf || function( obj ) {

                /*jshint proto: true */
                return obj.__proto__;
            };

        function useStrictEquality( b, a ) {

            // To catch short annotation VS &#x27;new&#x27; annotation of a declaration. e.g.:
            // &#x60;var i = 1;&#x60;
            // &#x60;var j = new Number(1);&#x60;
            if ( typeof a === &quot;object&quot; ) {
                a = a.valueOf();
            }
            if ( typeof b === &quot;object&quot; ) {
                b = b.valueOf();
            }

            return a === b;
        }

        function compareConstructors( a, b ) {
            var protoA = getProto( a );
            var protoB = getProto( b );

            // Comparing constructors is more strict than using &#x60;instanceof&#x60;
            if ( a.constructor === b.constructor ) {
                return true;
            }

            // Ref #851
            // If the obj prototype descends from a null constructor, treat it
            // as a null prototype.
            if ( protoA &amp;&amp; protoA.constructor === null ) {
                protoA = null;
            }
            if ( protoB &amp;&amp; protoB.constructor === null ) {
                protoB = null;
            }

            // Allow objects with no prototype to be equivalent to
            // objects with Object as their constructor.
            if ( ( protoA === null &amp;&amp; protoB === Object.prototype ) ||
                ( protoB === null &amp;&amp; protoA === Object.prototype ) ) {
                return true;
            }

            return false;
        }

        function getRegExpFlags( regexp ) {
            return &quot;flags&quot; in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];
        }

        var callbacks = {
            &quot;string&quot;: useStrictEquality,
            &quot;boolean&quot;: useStrictEquality,
            &quot;number&quot;: useStrictEquality,
            &quot;null&quot;: useStrictEquality,
            &quot;undefined&quot;: useStrictEquality,
            &quot;symbol&quot;: useStrictEquality,
            &quot;date&quot;: useStrictEquality,

            &quot;nan&quot;: function() {
                return true;
            },

            &quot;regexp&quot;: function( b, a ) {
                return a.source === b.source &amp;&amp;

                        // Include flags in the comparison
                    getRegExpFlags( a ) === getRegExpFlags( b );
            },

            // - skip when the property is a method of an instance (OOP)
            // - abort otherwise,
            // initial === would have catch identical references anyway
            &quot;function&quot;: function() {
                var caller = callers[ callers.length - 1 ];
                return caller !== Object &amp;&amp; typeof caller !== &quot;undefined&quot;;
            },

            &quot;array&quot;: function( b, a ) {
                var i, j, len, loop, aCircular, bCircular;

                len = a.length;
                if ( len !== b.length ) {
                    // safe and faster
                    return false;
                }

                // Track reference to avoid circular references
                parents.push( a );
                parentsB.push( b );
                for ( i = 0; i &lt; len; i++ ) {
                    loop = false;
                    for ( j = 0; j &lt; parents.length; j++ ) {
                        aCircular = parents[ j ] === a[ i ];
                        bCircular = parentsB[ j ] === b[ i ];
                        if ( aCircular || bCircular ) {
                            if ( a[ i ] === b[ i ] || aCircular &amp;&amp; bCircular ) {
                                loop = true;
                            } else {
                                parents.pop();
                                parentsB.pop();
                                return false;
                            }
                        }
                    }
                    if ( !loop &amp;&amp; !innerEquiv( a[ i ], b[ i ] ) ) {
                        parents.pop();
                        parentsB.pop();
                        return false;
                    }
                }
                parents.pop();
                parentsB.pop();
                return true;
            },

            &quot;set&quot;: function( b, a ) {
                var aArray, bArray;

                aArray = [];
                a.forEach( function( v ) {
                    aArray.push( v );
                });
                bArray = [];
                b.forEach( function( v ) {
                    bArray.push( v );
                });

                return innerEquiv( bArray, aArray );
            },

            &quot;map&quot;: function( b, a ) {
                var aArray, bArray;

                aArray = [];
                a.forEach( function( v, k ) {
                    aArray.push( [ k, v ] );
                });
                bArray = [];
                b.forEach( function( v, k ) {
                    bArray.push( [ k, v ] );
                });

                return innerEquiv( bArray, aArray );
            },

            &quot;object&quot;: function( b, a ) {
                var i, j, loop, aCircular, bCircular;

                // Default to true
                var eq = true;
                var aProperties = [];
                var bProperties = [];

                if ( compareConstructors( a, b ) === false ) {
                    return false;
                }

                // Stack constructor before traversing properties
                callers.push( a.constructor );

                // Track reference to avoid circular references
                parents.push( a );
                parentsB.push( b );

                // Be strict: don&#x27;t ensure hasOwnProperty and go deep
                for ( i in a ) {
                    loop = false;
                    for ( j = 0; j &lt; parents.length; j++ ) {
                        aCircular = parents[ j ] === a[ i ];
                        bCircular = parentsB[ j ] === b[ i ];
                        if ( aCircular || bCircular ) {
                            if ( a[ i ] === b[ i ] || aCircular &amp;&amp; bCircular ) {
                                loop = true;
                            } else {
                                eq = false;
                                break;
                            }
                        }
                    }
                    aProperties.push( i );
                    if ( !loop &amp;&amp; !innerEquiv( a[ i ], b[ i ] ) ) {
                        eq = false;
                        break;
                    }
                }

                parents.pop();
                parentsB.pop();

                // Unstack, we are done
                callers.pop();

                for ( i in b ) {

                    // Collect b&#x27;s properties
                    bProperties.push( i );
                }

                // Ensures identical properties name
                return eq &amp;&amp; innerEquiv( aProperties.sort(), bProperties.sort() );
            }
        };

        function typeEquiv( a, b ) {
            var type = QUnit.objectType( a );
            return QUnit.objectType( b ) === type &amp;&amp; callbacks[ type ]( b, a );
        }

        // The real equiv function
        function innerEquiv( a, b ) {

            // We&#x27;re done when there&#x27;s nothing more to compare
            if ( arguments.length &lt; 2 ) {
                return true;
            }

            // Require type-specific equality
            return ( a === b || typeEquiv( a, b ) ) &amp;&amp;

                    // ...across all consecutive argument pairs
                ( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );
        }

        return innerEquiv;
    }());

// Based on jsDump by Ariel Flesler
// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html
    QUnit.dump = (function() {
        function quote( str ) {
            return &quot;\&quot;&quot; + str.toString().replace( /\\/g, &quot;\\\\&quot; ).replace( /&quot;/g, &quot;\\\&quot;&quot; ) + &quot;\&quot;&quot;;
        }
        function literal( o ) {
            return o + &quot;&quot;;
        }
        function join( pre, arr, post ) {
            var s = dump.separator(),
                base = dump.indent(),
                inner = dump.indent( 1 );
            if ( arr.join ) {
                arr = arr.join( &quot;,&quot; + s + inner );
            }
            if ( !arr ) {
                return pre + post;
            }
            return [ pre, inner + arr, base + post ].join( s );
        }
        function array( arr, stack ) {
            var i = arr.length,
                ret = new Array( i );

            if ( dump.maxDepth &amp;&amp; dump.depth &gt; dump.maxDepth ) {
                return &quot;[object Array]&quot;;
            }

            this.up();
            while ( i-- ) {
                ret[ i ] = this.parse( arr[ i ], undefined, stack );
            }
            this.down();
            return join( &quot;[&quot;, ret, &quot;]&quot; );
        }

        var reName = /^function (\w+)/,
            dump = {

                // objType is used mostly internally, you can fix a (custom) type in advance
                parse: function( obj, objType, stack ) {
                    stack = stack || [];
                    var res, parser, parserType,
                        inStack = inArray( obj, stack );

                    if ( inStack !== -1 ) {
                        return &quot;recursion(&quot; + ( inStack - stack.length ) + &quot;)&quot;;
                    }

                    objType = objType || this.typeOf( obj  );
                    parser = this.parsers[ objType ];
                    parserType = typeof parser;

                    if ( parserType === &quot;function&quot; ) {
                        stack.push( obj );
                        res = parser.call( this, obj, stack );
                        stack.pop();
                        return res;
                    }
                    return ( parserType === &quot;string&quot; ) ? parser : this.parsers.error;
                },
                typeOf: function( obj ) {
                    var type;
                    if ( obj === null ) {
                        type = &quot;null&quot;;
                    } else if ( typeof obj === &quot;undefined&quot; ) {
                        type = &quot;undefined&quot;;
                    } else if ( QUnit.is( &quot;regexp&quot;, obj ) ) {
                        type = &quot;regexp&quot;;
                    } else if ( QUnit.is( &quot;date&quot;, obj ) ) {
                        type = &quot;date&quot;;
                    } else if ( QUnit.is( &quot;function&quot;, obj ) ) {
                        type = &quot;function&quot;;
                    } else if ( obj.setInterval !== undefined &amp;&amp;
                        obj.document !== undefined &amp;&amp;
                        obj.nodeType === undefined ) {
                        type = &quot;window&quot;;
                    } else if ( obj.nodeType === 9 ) {
                        type = &quot;document&quot;;
                    } else if ( obj.nodeType ) {
                        type = &quot;node&quot;;
                    } else if (

                        // native arrays
                    toString.call( obj ) === &quot;[object Array]&quot; ||

                        // NodeList objects
                    ( typeof obj.length === &quot;number&quot; &amp;&amp; obj.item !== undefined &amp;&amp;
                    ( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &amp;&amp;
                    obj[ 0 ] === undefined ) ) )
                    ) {
                        type = &quot;array&quot;;
                    } else if ( obj.constructor === Error.prototype.constructor ) {
                        type = &quot;error&quot;;
                    } else {
                        type = typeof obj;
                    }
                    return type;
                },
                separator: function() {
                    return this.multiline ? this.HTML ? &quot;&lt;br /&gt;&quot; : &quot;\n&quot; : this.HTML ? &quot;&amp;#160;&quot; : &quot; &quot;;
                },
                // extra can be a number, shortcut for increasing-calling-decreasing
                indent: function( extra ) {
                    if ( !this.multiline ) {
                        return &quot;&quot;;
                    }
                    var chr = this.indentChar;
                    if ( this.HTML ) {
                        chr = chr.replace( /\t/g, &quot;   &quot; ).replace( / /g, &quot;&amp;#160;&quot; );
                    }
                    return new Array( this.depth + ( extra || 0 ) ).join( chr );
                },
                up: function( a ) {
                    this.depth += a || 1;
                },
                down: function( a ) {
                    this.depth -= a || 1;
                },
                setParser: function( name, parser ) {
                    this.parsers[ name ] = parser;
                },
                // The next 3 are exposed so you can use them
                quote: quote,
                literal: literal,
                join: join,
                //
                depth: 1,
                maxDepth: QUnit.config.maxDepth,

                // This is the list of parsers, to modify them, use dump.setParser
                parsers: {
                    window: &quot;[Window]&quot;,
                    document: &quot;[Document]&quot;,
                    error: function( error ) {
                        return &quot;Error(\&quot;&quot; + error.message + &quot;\&quot;)&quot;;
                    },
                    unknown: &quot;[Unknown]&quot;,
                    &quot;null&quot;: &quot;null&quot;,
                    &quot;undefined&quot;: &quot;undefined&quot;,
                    &quot;function&quot;: function( fn ) {
                        var ret = &quot;function&quot;,

                        // functions never have name in IE
                            name = &quot;name&quot; in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];

                        if ( name ) {
                            ret += &quot; &quot; + name;
                        }
                        ret += &quot;( &quot;;

                        ret = [ ret, dump.parse( fn, &quot;functionArgs&quot; ), &quot;){&quot; ].join( &quot;&quot; );
                        return join( ret, dump.parse( fn, &quot;functionCode&quot; ), &quot;}&quot; );
                    },
                    array: array,
                    nodelist: array,
                    &quot;arguments&quot;: array,
                    object: function( map, stack ) {
                        var keys, key, val, i, nonEnumerableProperties,
                            ret = [];

                        if ( dump.maxDepth &amp;&amp; dump.depth &gt; dump.maxDepth ) {
                            return &quot;[object Object]&quot;;
                        }

                        dump.up();
                        keys = [];
                        for ( key in map ) {
                            keys.push( key );
                        }

                        // Some properties are not always enumerable on Error objects.
                        nonEnumerableProperties = [ &quot;message&quot;, &quot;name&quot; ];
                        for ( i in nonEnumerableProperties ) {
                            key = nonEnumerableProperties[ i ];
                            if ( key in map &amp;&amp; inArray( key, keys ) &lt; 0 ) {
                                keys.push( key );
                            }
                        }
                        keys.sort();
                        for ( i = 0; i &lt; keys.length; i++ ) {
                            key = keys[ i ];
                            val = map[ key ];
                            ret.push( dump.parse( key, &quot;key&quot; ) + &quot;: &quot; +
                                dump.parse( val, undefined, stack ) );
                        }
                        dump.down();
                        return join( &quot;{&quot;, ret, &quot;}&quot; );
                    },
                    node: function( node ) {
                        var len, i, val,
                            open = dump.HTML ? &quot;&amp;lt;&quot; : &quot;&lt;&quot;,
                            close = dump.HTML ? &quot;&amp;gt;&quot; : &quot;&gt;&quot;,
                            tag = node.nodeName.toLowerCase(),
                            ret = open + tag,
                            attrs = node.attributes;

                        if ( attrs ) {
                            for ( i = 0, len = attrs.length; i &lt; len; i++ ) {
                                val = attrs[ i ].nodeValue;

                                // IE6 includes all attributes in .attributes, even ones not explicitly
                                // set. Those have values like undefined, null, 0, false, &quot;&quot; or
                                // &quot;inherit&quot;.
                                if ( val &amp;&amp; val !== &quot;inherit&quot; ) {
                                    ret += &quot; &quot; + attrs[ i ].nodeName + &quot;=&quot; +
                                        dump.parse( val, &quot;attribute&quot; );
                                }
                            }
                        }
                        ret += close;

                        // Show content of TextNode or CDATASection
                        if ( node.nodeType === 3 || node.nodeType === 4 ) {
                            ret += node.nodeValue;
                        }

                        return ret + open + &quot;/&quot; + tag + close;
                    },

                    // function calls it internally, it&#x27;s the arguments part of the function
                    functionArgs: function( fn ) {
                        var args,
                            l = fn.length;

                        if ( !l ) {
                            return &quot;&quot;;
                        }

                        args = new Array( l );
                        while ( l-- ) {

                            // 97 is &#x27;a&#x27;
                            args[ l ] = String.fromCharCode( 97 + l );
                        }
                        return &quot; &quot; + args.join( &quot;, &quot; ) + &quot; &quot;;
                    },
                    // object calls it internally, the key part of an item in a map
                    key: quote,
                    // function calls it internally, it&#x27;s the content of the function
                    functionCode: &quot;[code]&quot;,
                    // node calls it internally, it&#x27;s a html attribute value
                    attribute: quote,
                    string: quote,
                    date: quote,
                    regexp: literal,
                    number: literal,
                    &quot;boolean&quot;: literal
                },
                // if true, entities are escaped ( &lt;, &gt;, \t, space and \n )
                HTML: false,
                // indentation unit
                indentChar: &quot;  &quot;,
                // if true, items in a collection, are separated by a \n, else just a space.
                multiline: true
            };

        return dump;
    }());

// back compat
    QUnit.jsDump = QUnit.dump;

// Deprecated
// Extend assert methods to QUnit for Backwards compatibility
    (function() {
        var i,
            assertions = Assert.prototype;

        function applyCurrent( current ) {
            return function() {
                var assert = new Assert( QUnit.config.current );
                current.apply( assert, arguments );
            };
        }

        for ( i in assertions ) {
            QUnit[ i ] = applyCurrent( assertions[ i ] );
        }
    })();

// For browser, export only select globals
    if ( defined.document ) {

        (function() {
            var i, l,
                keys = [
                    &quot;test&quot;,
                    &quot;module&quot;,
                    &quot;expect&quot;,
                    &quot;asyncTest&quot;,
                    &quot;start&quot;,
                    &quot;stop&quot;,
                    &quot;ok&quot;,
                    &quot;notOk&quot;,
                    &quot;equal&quot;,
                    &quot;notEqual&quot;,
                    &quot;propEqual&quot;,
                    &quot;notPropEqual&quot;,
                    &quot;deepEqual&quot;,
                    &quot;notDeepEqual&quot;,
                    &quot;strictEqual&quot;,
                    &quot;notStrictEqual&quot;,
                    &quot;throws&quot;,
                    &quot;raises&quot;
                ];

            for ( i = 0, l = keys.length; i &lt; l; i++ ) {
                window[ keys[ i ] ] = QUnit[ keys[ i ] ];
            }
        })();

        window.QUnit = QUnit;
    }

// For nodejs
    if ( typeof module !== &quot;undefined&quot; &amp;&amp; module &amp;&amp; module.exports ) {
        module.exports = QUnit;

        // For consistency with CommonJS environments&#x27; exports
        module.exports.QUnit = QUnit;
    }

// For CommonJS with exports, but without module.exports, like Rhino
    if ( typeof exports !== &quot;undefined&quot; &amp;&amp; exports ) {
        exports.QUnit = QUnit;
    }

    if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {
        define( function() {
            return QUnit;
        } );
        QUnit.config.autostart = false;
    }

    /*
     * This file is a modified version of google-diff-match-patch&#x27;s JavaScript implementation
     * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),
     * modifications are licensed as more fully set forth in LICENSE.txt.
     *
     * The original source of google-diff-match-patch is attributable and licensed as follows:
     *
     * Copyright 2006 Google Inc.
     * https://code.google.com/p/google-diff-match-patch/
     *
     * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * More Info:
     *  https://code.google.com/p/google-diff-match-patch/
     *
     * Usage: QUnit.diff(expected, actual)
     *
     */
    QUnit.diff = ( function() {
        function DiffMatchPatch() {
        }

        //  DIFF FUNCTIONS

        /**
         * The data structure representing a diff is an array of tuples:
         * [[DIFF_DELETE, &#x27;Hello&#x27;], [DIFF_INSERT, &#x27;Goodbye&#x27;], [DIFF_EQUAL, &#x27; world.&#x27;]]
         * which means: delete &#x27;Hello&#x27;, add &#x27;Goodbye&#x27; and keep &#x27; world.&#x27;
         */
        var DIFF_DELETE = -1,
            DIFF_INSERT = 1,
            DIFF_EQUAL = 0;

        /**
         * Find the differences between two texts.  Simplifies the problem by stripping
         * any common prefix or suffix off the texts before diffing.
         * @param {string} text1 Old string to be diffed.
         * @param {string} text2 New string to be diffed.
         * @param {boolean=} optChecklines Optional speedup flag. If present and false,
         *     then don&#x27;t run a line-level diff first to identify the changed areas.
         *     Defaults to true, which does a faster, slightly less optimal diff.
         * @return {!Array.&lt;!DiffMatchPatch.Diff&gt;} Array of diff tuples.
         */
        DiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {
            var deadline, checklines, commonlength,
                commonprefix, commonsuffix, diffs;

            // The diff must be complete in up to 1 second.
            deadline = ( new Date() ).getTime() + 1000;

            // Check for null inputs.
            if ( text1 === null || text2 === null ) {
                throw new Error( &quot;Null input. (DiffMain)&quot; );
            }

            // Check for equality (speedup).
            if ( text1 === text2 ) {
                if ( text1 ) {
                    return [
                        [ DIFF_EQUAL, text1 ]
                    ];
                }
                return [];
            }

            if ( typeof optChecklines === &quot;undefined&quot; ) {
                optChecklines = true;
            }

            checklines = optChecklines;

            // Trim off common prefix (speedup).
            commonlength = this.diffCommonPrefix( text1, text2 );
            commonprefix = text1.substring( 0, commonlength );
            text1 = text1.substring( commonlength );
            text2 = text2.substring( commonlength );

            // Trim off common suffix (speedup).
            commonlength = this.diffCommonSuffix( text1, text2 );
            commonsuffix = text1.substring( text1.length - commonlength );
            text1 = text1.substring( 0, text1.length - commonlength );
            text2 = text2.substring( 0, text2.length - commonlength );

            // Compute the diff on the middle block.
            diffs = this.diffCompute( text1, text2, checklines, deadline );

            // Restore the prefix and suffix.
            if ( commonprefix ) {
                diffs.unshift( [ DIFF_EQUAL, commonprefix ] );
            }
            if ( commonsuffix ) {
                diffs.push( [ DIFF_EQUAL, commonsuffix ] );
            }
            this.diffCleanupMerge( diffs );
            return diffs;
        };

        /**
         * Reduce the number of edits by eliminating operationally trivial equalities.
         * @param {!Array.&lt;!DiffMatchPatch.Diff&gt;} diffs Array of diff tuples.
         */
        DiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {
            var changes, equalities, equalitiesLength, lastequality,
                pointer, preIns, preDel, postIns, postDel;
            changes = false;
            equalities = []; // Stack of indices where equalities are found.
            equalitiesLength = 0; // Keeping our own length var is faster in JS.
            /** @type {?string} */
            lastequality = null;
            // Always equal to diffs[equalities[equalitiesLength - 1]][1]
            pointer = 0; // Index of current position.
            // Is there an insertion operation before the last equality.
            preIns = false;
            // Is there a deletion operation before the last equality.
            preDel = false;
            // Is there an insertion operation after the last equality.
            postIns = false;
            // Is there a deletion operation after the last equality.
            postDel = false;
            while ( pointer &lt; diffs.length ) {

                // Equality found.
                if ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {
                    if ( diffs[ pointer ][ 1 ].length &lt; 4 &amp;&amp; ( postIns || postDel ) ) {

                        // Candidate found.
                        equalities[ equalitiesLength++ ] = pointer;
                        preIns = postIns;
                        preDel = postDel;
                        lastequality = diffs[ pointer ][ 1 ];
                    } else {

                        // Not a candidate, and can never become one.
                        equalitiesLength = 0;
                        lastequality = null;
                    }
                    postIns = postDel = false;

                    // An insertion or deletion.
                } else {

                    if ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {
                        postDel = true;
                    } else {
                        postIns = true;
                    }

                    /*
                     * Five types to be split:
                     * &lt;ins&gt;A&lt;/ins&gt;&lt;del&gt;B&lt;/del&gt;XY&lt;ins&gt;C&lt;/ins&gt;&lt;del&gt;D&lt;/del&gt;
                     * &lt;ins&gt;A&lt;/ins&gt;X&lt;ins&gt;C&lt;/ins&gt;&lt;del&gt;D&lt;/del&gt;
                     * &lt;ins&gt;A&lt;/ins&gt;&lt;del&gt;B&lt;/del&gt;X&lt;ins&gt;C&lt;/ins&gt;
                     * &lt;ins&gt;A&lt;/del&gt;X&lt;ins&gt;C&lt;/ins&gt;&lt;del&gt;D&lt;/del&gt;
                     * &lt;ins&gt;A&lt;/ins&gt;&lt;del&gt;B&lt;/del&gt;X&lt;del&gt;C&lt;/del&gt;
                     */
                    if ( lastequality &amp;&amp; ( ( preIns &amp;&amp; preDel &amp;&amp; postIns &amp;&amp; postDel ) ||
                        ( ( lastequality.length &lt; 2 ) &amp;&amp;
                        ( preIns + preDel + postIns + postDel ) === 3 ) ) ) {

                        // Duplicate record.
                        diffs.splice(
                            equalities[ equalitiesLength - 1 ],
                            0,
                            [ DIFF_DELETE, lastequality ]
                        );

                        // Change second copy to insert.
                        diffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;
                        equalitiesLength--; // Throw away the equality we just deleted;
                        lastequality = null;
                        if ( preIns &amp;&amp; preDel ) {
                            // No changes made which could affect previous entry, keep going.
                            postIns = postDel = true;
                            equalitiesLength = 0;
                        } else {
                            equalitiesLength--; // Throw away the previous equality.
                            pointer = equalitiesLength &gt; 0 ? equalities[ equalitiesLength - 1 ] : -1;
                            postIns = postDel = false;
                        }
                        changes = true;
                    }
                }
                pointer++;
            }

            if ( changes ) {
                this.diffCleanupMerge( diffs );
            }
        };

        /**
         * Convert a diff array into a pretty HTML report.
         * @param {!Array.&lt;!DiffMatchPatch.Diff&gt;} diffs Array of diff tuples.
         * @param {integer} string to be beautified.
         * @return {string} HTML representation.
         */
        DiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {
            var op, data, x,
                html = [];
            for ( x = 0; x &lt; diffs.length; x++ ) {
                op = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)
                data = diffs[ x ][ 1 ]; // Text of change.
                switch ( op ) {
                    case DIFF_INSERT:
                        html[ x ] = &quot;&lt;ins&gt;&quot; + data + &quot;&lt;/ins&gt;&quot;;
                        break;
                    case DIFF_DELETE:
                        html[ x ] = &quot;&lt;del&gt;&quot; + data + &quot;&lt;/del&gt;&quot;;
                        break;
                    case DIFF_EQUAL:
                        html[ x ] = &quot;&lt;span&gt;&quot; + data + &quot;&lt;/span&gt;&quot;;
                        break;
                }
            }
            return html.join( &quot;&quot; );
        };

        /**
         * Determine the common prefix of two strings.
         * @param {string} text1 First string.
         * @param {string} text2 Second string.
         * @return {number} The number of characters common to the start of each
         *     string.
         */
        DiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {
            var pointermid, pointermax, pointermin, pointerstart;
            // Quick check for common null cases.
            if ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {
                return 0;
            }
            // Binary search.
            // Performance analysis: https://neil.fraser.name/news/2007/10/09/
            pointermin = 0;
            pointermax = Math.min( text1.length, text2.length );
            pointermid = pointermax;
            pointerstart = 0;
            while ( pointermin &lt; pointermid ) {
                if ( text1.substring( pointerstart, pointermid ) ===
                    text2.substring( pointerstart, pointermid ) ) {
                    pointermin = pointermid;
                    pointerstart = pointermin;
                } else {
                    pointermax = pointermid;
                }
                pointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );
            }
            return pointermid;
        };

        /**
         * Determine the common suffix of two strings.
         * @param {string} text1 First string.
         * @param {string} text2 Second string.
         * @return {number} The number of characters common to the end of each string.
         */
        DiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {
            var pointermid, pointermax, pointermin, pointerend;
            // Quick check for common null cases.
            if ( !text1 ||
                !text2 ||
                text1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {
                return 0;
            }
            // Binary search.
            // Performance analysis: https://neil.fraser.name/news/2007/10/09/
            pointermin = 0;
            pointermax = Math.min( text1.length, text2.length );
            pointermid = pointermax;
            pointerend = 0;
            while ( pointermin &lt; pointermid ) {
                if ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===
                    text2.substring( text2.length - pointermid, text2.length - pointerend ) ) {
                    pointermin = pointermid;
                    pointerend = pointermin;
                } else {
                    pointermax = pointermid;
                }
                pointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );
            }
            return pointermid;
        };

        /**
         * Find the differences between two texts.  Assumes that the texts do not
         * have any common prefix or suffix.
         * @param {string} text1 Old string to be diffed.
         * @param {string} text2 New string to be diffed.
         * @param {boolean} checklines Speedup flag.  If false, then don&#x27;t run a
         *     line-level diff first to identify the changed areas.
         *     If true, then run a faster, slightly less optimal diff.
         * @param {number} deadline Time when the diff should be complete by.
         * @return {!Array.&lt;!DiffMatchPatch.Diff&gt;} Array of diff tuples.
         * @private
         */
        DiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {
            var diffs, longtext, shorttext, i, hm,
                text1A, text2A, text1B, text2B,
                midCommon, diffsA, diffsB;

            if ( !text1 ) {
                // Just add some text (speedup).
                return [
                    [ DIFF_INSERT, text2 ]
                ];
            }

            if ( !text2 ) {
                // Just delete some text (speedup).
                return [
                    [ DIFF_DELETE, text1 ]
                ];
            }

            longtext = text1.length &gt; text2.length ? text1 : text2;
            shorttext = text1.length &gt; text2.length ? text2 : text1;
            i = longtext.indexOf( shorttext );
            if ( i !== -1 ) {
                // Shorter text is inside the longer text (speedup).
                diffs = [
                    [ DIFF_INSERT, longtext.substring( 0, i ) ],
                    [ DIFF_EQUAL, shorttext ],
                    [ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]
                ];
                // Swap insertions for deletions if diff is reversed.
                if ( text1.length &gt; text2.length ) {
                    diffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;
                }
                return diffs;
            }

            if ( shorttext.length === 1 ) {
                // Single character string.
                // After the previous speedup, the character can&#x27;t be an equality.
                return [
                    [ DIFF_DELETE, text1 ],
                    [ DIFF_INSERT, text2 ]
                ];
            }

            // Check to see if the problem can be split in two.
            hm = this.diffHalfMatch( text1, text2 );
            if ( hm ) {
                // A half-match was found, sort out the return data.
                text1A = hm[ 0 ];
                text1B = hm[ 1 ];
                text2A = hm[ 2 ];
                text2B = hm[ 3 ];
                midCommon = hm[ 4 ];
                // Send both pairs off for separate processing.
                diffsA = this.DiffMain( text1A, text2A, checklines, deadline );
                diffsB = this.DiffMain( text1B, text2B, checklines, deadline );
                // Merge the results.
                return diffsA.concat( [
                    [ DIFF_EQUAL, midCommon ]
                ], diffsB );
            }

            if ( checklines &amp;&amp; text1.length &gt; 100 &amp;&amp; text2.length &gt; 100 ) {
                return this.diffLineMode( text1, text2, deadline );
            }

            return this.diffBisect( text1, text2, deadline );
        };

        /**
         * Do the two texts share a substring which is at least half the length of the
         * longer text?
         * This speedup can produce non-minimal diffs.
         * @param {string} text1 First string.
         * @param {string} text2 Second string.
         * @return {Array.&lt;string&gt;} Five element Array, containing the prefix of
         *     text1, the suffix of text1, the prefix of text2, the suffix of
         *     text2 and the common middle.  Or null if there was no match.
         * @private
         */
        DiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {
            var longtext, shorttext, dmp,
                text1A, text2B, text2A, text1B, midCommon,
                hm1, hm2, hm;

            longtext = text1.length &gt; text2.length ? text1 : text2;
            shorttext = text1.length &gt; text2.length ? text2 : text1;
            if ( longtext.length &lt; 4 || shorttext.length * 2 &lt; longtext.length ) {
                return null; // Pointless.
            }
            dmp = this; // &#x27;this&#x27; becomes &#x27;window&#x27; in a closure.

            /**
             * Does a substring of shorttext exist within longtext such that the substring
             * is at least half the length of longtext?
             * Closure, but does not reference any external variables.
             * @param {string} longtext Longer string.
             * @param {string} shorttext Shorter string.
             * @param {number} i Start index of quarter length substring within longtext.
             * @return {Array.&lt;string&gt;} Five element Array, containing the prefix of
             *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
             *     of shorttext and the common middle.  Or null if there was no match.
             * @private
             */
            function diffHalfMatchI( longtext, shorttext, i ) {
                var seed, j, bestCommon, prefixLength, suffixLength,
                    bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;
                // Start with a 1/4 length substring at position i as a seed.
                seed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );
                j = -1;
                bestCommon = &quot;&quot;;
                while ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {
                    prefixLength = dmp.diffCommonPrefix( longtext.substring( i ),
                        shorttext.substring( j ) );
                    suffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),
                        shorttext.substring( 0, j ) );
                    if ( bestCommon.length &lt; suffixLength + prefixLength ) {
                        bestCommon = shorttext.substring( j - suffixLength, j ) +
                            shorttext.substring( j, j + prefixLength );
                        bestLongtextA = longtext.substring( 0, i - suffixLength );
                        bestLongtextB = longtext.substring( i + prefixLength );
                        bestShorttextA = shorttext.substring( 0, j - suffixLength );
                        bestShorttextB = shorttext.substring( j + prefixLength );
                    }
                }
                if ( bestCommon.length * 2 &gt;= longtext.length ) {
                    return [ bestLongtextA, bestLongtextB,
                        bestShorttextA, bestShorttextB, bestCommon
                    ];
                } else {
                    return null;
                }
            }

            // First check if the second quarter is the seed for a half-match.
            hm1 = diffHalfMatchI( longtext, shorttext,
                Math.ceil( longtext.length / 4 ) );
            // Check again based on the third quarter.
            hm2 = diffHalfMatchI( longtext, shorttext,
                Math.ceil( longtext.length / 2 ) );
            if ( !hm1 &amp;&amp; !hm2 ) {
                return null;
            } else if ( !hm2 ) {
                hm = hm1;
            } else if ( !hm1 ) {
                hm = hm2;
            } else {
                // Both matched.  Select the longest.
                hm = hm1[ 4 ].length &gt; hm2[ 4 ].length ? hm1 : hm2;
            }

            // A half-match was found, sort out the return data.
            text1A, text1B, text2A, text2B;
            if ( text1.length &gt; text2.length ) {
                text1A = hm[ 0 ];
                text1B = hm[ 1 ];
                text2A = hm[ 2 ];
                text2B = hm[ 3 ];
            } else {
                text2A = hm[ 0 ];
                text2B = hm[ 1 ];
                text1A = hm[ 2 ];
                text1B = hm[ 3 ];
            }
            midCommon = hm[ 4 ];
            return [ text1A, text1B, text2A, text2B, midCommon ];
        };

        /**
         * Do a quick line-level diff on both strings, then rediff the parts for
         * greater accuracy.
         * This speedup can produce non-minimal diffs.
         * @param {string} text1 Old string to be diffed.
         * @param {string} text2 New string to be diffed.
         * @param {number} deadline Time when the diff should be complete by.
         * @return {!Array.&lt;!DiffMatchPatch.Diff&gt;} Array of diff tuples.
         * @private
         */
        DiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {
            var a, diffs, linearray, pointer, countInsert,
                countDelete, textInsert, textDelete, j;
            // Scan the text on a line-by-line basis first.
            a = this.diffLinesToChars( text1, text2 );
            text1 = a.chars1;
            text2 = a.chars2;
            linearray = a.lineArray;

            diffs = this.DiffMain( text1, text2, false, deadline );

            // Convert the diff back to original text.
            this.diffCharsToLines( diffs, linearray );
            // Eliminate freak matches (e.g. blank lines)
            this.diffCleanupSemantic( diffs );

            // Rediff any replacement blocks, this time character-by-character.
            // Add a dummy entry at the end.
            diffs.push( [ DIFF_EQUAL, &quot;&quot; ] );
            pointer = 0;
            countDelete = 0;
            countInsert = 0;
            textDelete = &quot;&quot;;
            textInsert = &quot;&quot;;
            while ( pointer &lt; diffs.length ) {
                switch ( diffs[ pointer ][ 0 ] ) {
                    case DIFF_INSERT:
                        countInsert++;
                        textInsert += diffs[ pointer ][ 1 ];
                        break;
                    case DIFF_DELETE:
                        countDelete++;
                        textDelete += diffs[ pointer ][ 1 ];
                        break;
                    case DIFF_EQUAL:
                        // Upon reaching an equality, check for prior redundancies.
                        if ( countDelete &gt;= 1 &amp;&amp; countInsert &gt;= 1 ) {
                            // Delete the offending records and add the merged ones.
                            diffs.splice( pointer - countDelete - countInsert,
                                countDelete + countInsert );
                            pointer = pointer - countDelete - countInsert;
                            a = this.DiffMain( textDelete, textInsert, false, deadline );
                            for ( j = a.length - 1; j &gt;= 0; j-- ) {
                                diffs.splice( pointer, 0, a[ j ] );
                            }
                            pointer = pointer + a.length;
                        }
                        countInsert = 0;
                        countDelete = 0;
                        textDelete = &quot;&quot;;
                        textInsert = &quot;&quot;;
                        break;
                }
                pointer++;
            }
            diffs.pop(); // Remove the dummy entry at the end.

            return diffs;
        };

        /**
         * Find the &#x27;middle snake&#x27; of a diff, split the problem in two
         * and return the recursively constructed diff.
         * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
         * @param {string} text1 Old string to be diffed.
         * @param {string} text2 New string to be diffed.
         * @param {number} deadline Time at which to bail if not yet complete.
         * @return {!Array.&lt;!DiffMatchPatch.Diff&gt;} Array of diff tuples.
         * @private
         */
        DiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {
            var text1Length, text2Length, maxD, vOffset, vLength,
                v1, v2, x, delta, front, k1start, k1end, k2start,
                k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;
            // Cache the text lengths to prevent multiple calls.
            text1Length = text1.length;
            text2Length = text2.length;
            maxD = Math.ceil( ( text1Length + text2Length ) / 2 );
            vOffset = maxD;
            vLength = 2 * maxD;
            v1 = new Array( vLength );
            v2 = new Array( vLength );
            // Setting all elements to -1 is faster in Chrome &amp; Firefox than mixing
            // integers and undefined.
            for ( x = 0; x &lt; vLength; x++ ) {
                v1[ x ] = -1;
                v2[ x ] = -1;
            }
            v1[ vOffset + 1 ] = 0;
            v2[ vOffset + 1 ] = 0;
            delta = text1Length - text2Length;
            // If the total number of characters is odd, then the front path will collide
            // with the reverse path.
            front = ( delta % 2 !== 0 );
            // Offsets for start and end of k loop.
            // Prevents mapping of space beyond the grid.
            k1start = 0;
            k1end = 0;
            k2start = 0;
            k2end = 0;
            for ( d = 0; d &lt; maxD; d++ ) {
                // Bail out if deadline is reached.
                if ( ( new Date() ).getTime() &gt; deadline ) {
                    break;
                }

                // Walk the front path one step.
                for ( k1 = -d + k1start; k1 &lt;= d - k1end; k1 += 2 ) {
                    k1Offset = vOffset + k1;
                    if ( k1 === -d || ( k1 !== d &amp;&amp; v1[ k1Offset - 1 ] &lt; v1[ k1Offset + 1 ] ) ) {
                        x1 = v1[ k1Offset + 1 ];
                    } else {
                        x1 = v1[ k1Offset - 1 ] + 1;
                    }
                    y1 = x1 - k1;
                    while ( x1 &lt; text1Length &amp;&amp; y1 &lt; text2Length &amp;&amp;
                    text1.charAt( x1 ) === text2.charAt( y1 ) ) {
                        x1++;
                        y1++;
                    }
                    v1[ k1Offset ] = x1;
                    if ( x1 &gt; text1Length ) {
                        // Ran off the right of the graph.
                        k1end += 2;
                    } else if ( y1 &gt; text2Length ) {
                        // Ran off the bottom of the graph.
                        k1start += 2;
                    } else if ( front ) {
                        k2Offset = vOffset + delta - k1;
                        if ( k2Offset &gt;= 0 &amp;&amp; k2Offset &lt; vLength &amp;&amp; v2[ k2Offset ] !== -1 ) {
                            // Mirror x2 onto top-left coordinate system.
                            x2 = text1Length - v2[ k2Offset ];
                            if ( x1 &gt;= x2 ) {
                                // Overlap detected.
                                return this.diffBisectSplit( text1, text2, x1, y1, deadline );
                            }
                        }
                    }
                }

                // Walk the reverse path one step.
                for ( k2 = -d + k2start; k2 &lt;= d - k2end; k2 += 2 ) {
                    k2Offset = vOffset + k2;
                    if ( k2 === -d || ( k2 !== d &amp;&amp; v2[ k2Offset - 1 ] &lt; v2[ k2Offset + 1 ] ) ) {
                        x2 = v2[ k2Offset + 1 ];
                    } else {
                        x2 = v2[ k2Offset - 1 ] + 1;
                    }
                    y2 = x2 - k2;
                    while ( x2 &lt; text1Length &amp;&amp; y2 &lt; text2Length &amp;&amp;
                    text1.charAt( text1Length - x2 - 1 ) ===
                    text2.charAt( text2Length - y2 - 1 ) ) {
                        x2++;
                        y2++;
                    }
                    v2[ k2Offset ] = x2;
                    if ( x2 &gt; text1Length ) {
                        // Ran off the left of the graph.
                        k2end += 2;
                    } else if ( y2 &gt; text2Length ) {
                        // Ran off the top of the graph.
                        k2start += 2;
                    } else if ( !front ) {
                        k1Offset = vOffset + delta - k2;
                        if ( k1Offset &gt;= 0 &amp;&amp; k1Offset &lt; vLength &amp;&amp; v1[ k1Offset ] !== -1 ) {
                            x1 = v1[ k1Offset ];
                            y1 = vOffset + x1 - k1Offset;
                            // Mirror x2 onto top-left coordinate system.
                            x2 = text1Length - x2;
                            if ( x1 &gt;= x2 ) {
                                // Overlap detected.
                                return this.diffBisectSplit( text1, text2, x1, y1, deadline );
                            }
                        }
                    }
                }
            }
            // Diff took too long and hit the deadline or
            // number of diffs equals number of characters, no commonality at all.
            return [
                [ DIFF_DELETE, text1 ],
                [ DIFF_INSERT, text2 ]
            ];
        };

        /**
         * Given the location of the &#x27;middle snake&#x27;, split the diff in two parts
         * and recurse.
         * @param {string} text1 Old string to be diffed.
         * @param {string} text2 New string to be diffed.
         * @param {number} x Index of split point in text1.
         * @param {number} y Index of split point in text2.
         * @param {number} deadline Time at which to bail if not yet complete.
         * @return {!Array.&lt;!DiffMatchPatch.Diff&gt;} Array of diff tuples.
         * @private
         */
        DiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {
            var text1a, text1b, text2a, text2b, diffs, diffsb;
            text1a = text1.substring( 0, x );
            text2a = text2.substring( 0, y );
            text1b = text1.substring( x );
            text2b = text2.substring( y );

            // Compute both diffs serially.
            diffs = this.DiffMain( text1a, text2a, false, deadline );
            diffsb = this.DiffMain( text1b, text2b, false, deadline );

            return diffs.concat( diffsb );
        };

        /**
         * Reduce the number of edits by eliminating semantically trivial equalities.
         * @param {!Array.&lt;!DiffMatchPatch.Diff&gt;} diffs Array of diff tuples.
         */
        DiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {
            var changes, equalities, equalitiesLength, lastequality,
                pointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,
                lengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;
            changes = false;
            equalities = []; // Stack of indices where equalities are found.
            equalitiesLength = 0; // Keeping our own length var is faster in JS.
            /** @type {?string} */
            lastequality = null;
            // Always equal to diffs[equalities[equalitiesLength - 1]][1]
            pointer = 0; // Index of current position.
            // Number of characters that changed prior to the equality.
            lengthInsertions1 = 0;
            lengthDeletions1 = 0;
            // Number of characters that changed after the equality.
            lengthInsertions2 = 0;
            lengthDeletions2 = 0;
            while ( pointer &lt; diffs.length ) {
                if ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.
                    equalities[ equalitiesLength++ ] = pointer;
                    lengthInsertions1 = lengthInsertions2;
                    lengthDeletions1 = lengthDeletions2;
                    lengthInsertions2 = 0;
                    lengthDeletions2 = 0;
                    lastequality = diffs[ pointer ][ 1 ];
                } else { // An insertion or deletion.
                    if ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {
                        lengthInsertions2 += diffs[ pointer ][ 1 ].length;
                    } else {
                        lengthDeletions2 += diffs[ pointer ][ 1 ].length;
                    }
                    // Eliminate an equality that is smaller or equal to the edits on both
                    // sides of it.
                    if ( lastequality &amp;&amp; ( lastequality.length &lt;=
                        Math.max( lengthInsertions1, lengthDeletions1 ) ) &amp;&amp;
                        ( lastequality.length &lt;= Math.max( lengthInsertions2,
                            lengthDeletions2 ) ) ) {

                        // Duplicate record.
                        diffs.splice(
                            equalities[ equalitiesLength - 1 ],
                            0,
                            [ DIFF_DELETE, lastequality ]
                        );

                        // Change second copy to insert.
                        diffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;

                        // Throw away the equality we just deleted.
                        equalitiesLength--;

                        // Throw away the previous equality (it needs to be reevaluated).
                        equalitiesLength--;
                        pointer = equalitiesLength &gt; 0 ? equalities[ equalitiesLength - 1 ] : -1;

                        // Reset the counters.
                        lengthInsertions1 = 0;
                        lengthDeletions1 = 0;
                        lengthInsertions2 = 0;
                        lengthDeletions2 = 0;
                        lastequality = null;
                        changes = true;
                    }
                }
                pointer++;
            }

            // Normalize the diff.
            if ( changes ) {
                this.diffCleanupMerge( diffs );
            }

            // Find any overlaps between deletions and insertions.
            // e.g: &lt;del&gt;abcxxx&lt;/del&gt;&lt;ins&gt;xxxdef&lt;/ins&gt;
            //   -&gt; &lt;del&gt;abc&lt;/del&gt;xxx&lt;ins&gt;def&lt;/ins&gt;
            // e.g: &lt;del&gt;xxxabc&lt;/del&gt;&lt;ins&gt;defxxx&lt;/ins&gt;
            //   -&gt; &lt;ins&gt;def&lt;/ins&gt;xxx&lt;del&gt;abc&lt;/del&gt;
            // Only extract an overlap if it is as big as the edit ahead or behind it.
            pointer = 1;
            while ( pointer &lt; diffs.length ) {
                if ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &amp;&amp;
                    diffs[ pointer ][ 0 ] === DIFF_INSERT ) {
                    deletion = diffs[ pointer - 1 ][ 1 ];
                    insertion = diffs[ pointer ][ 1 ];
                    overlapLength1 = this.diffCommonOverlap( deletion, insertion );
                    overlapLength2 = this.diffCommonOverlap( insertion, deletion );
                    if ( overlapLength1 &gt;= overlapLength2 ) {
                        if ( overlapLength1 &gt;= deletion.length / 2 ||
                            overlapLength1 &gt;= insertion.length / 2 ) {
                            // Overlap found.  Insert an equality and trim the surrounding edits.
                            diffs.splice(
                                pointer,
                                0,
                                [ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]
                            );
                            diffs[ pointer - 1 ][ 1 ] =
                                deletion.substring( 0, deletion.length - overlapLength1 );
                            diffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );
                            pointer++;
                        }
                    } else {
                        if ( overlapLength2 &gt;= deletion.length / 2 ||
                            overlapLength2 &gt;= insertion.length / 2 ) {

                            // Reverse overlap found.
                            // Insert an equality and swap and trim the surrounding edits.
                            diffs.splice(
                                pointer,
                                0,
                                [ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]
                            );

                            diffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;
                            diffs[ pointer - 1 ][ 1 ] =
                                insertion.substring( 0, insertion.length - overlapLength2 );
                            diffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;
                            diffs[ pointer + 1 ][ 1 ] =
                                deletion.substring( overlapLength2 );
                            pointer++;
                        }
                    }
                    pointer++;
                }
                pointer++;
            }
        };

        /**
         * Determine if the suffix of one string is the prefix of another.
         * @param {string} text1 First string.
         * @param {string} text2 Second string.
         * @return {number} The number of characters common to the end of the first
         *     string and the start of the second string.
         * @private
         */
        DiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {
            var text1Length, text2Length, textLength,
                best, length, pattern, found;
            // Cache the text lengths to prevent multiple calls.
            text1Length = text1.length;
            text2Length = text2.length;
            // Eliminate the null case.
            if ( text1Length === 0 || text2Length === 0 ) {
                return 0;
            }
            // Truncate the longer string.
            if ( text1Length &gt; text2Length ) {
                text1 = text1.substring( text1Length - text2Length );
            } else if ( text1Length &lt; text2Length ) {
                text2 = text2.substring( 0, text1Length );
            }
            textLength = Math.min( text1Length, text2Length );
            // Quick check for the worst case.
            if ( text1 === text2 ) {
                return textLength;
            }

            // Start by looking for a single character match
            // and increase length until no match is found.
            // Performance analysis: https://neil.fraser.name/news/2010/11/04/
            best = 0;
            length = 1;
            while ( true ) {
                pattern = text1.substring( textLength - length );
                found = text2.indexOf( pattern );
                if ( found === -1 ) {
                    return best;
                }
                length += found;
                if ( found === 0 || text1.substring( textLength - length ) ===
                    text2.substring( 0, length ) ) {
                    best = length;
                    length++;
                }
            }
        };

        /**
         * Split two texts into an array of strings.  Reduce the texts to a string of
         * hashes where each Unicode character represents one line.
         * @param {string} text1 First string.
         * @param {string} text2 Second string.
         * @return {{chars1: string, chars2: string, lineArray: !Array.&lt;string&gt;}}
         *     An object containing the encoded text1, the encoded text2 and
         *     the array of unique strings.
         *     The zeroth element of the array of unique strings is intentionally blank.
         * @private
         */
        DiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {
            var lineArray, lineHash, chars1, chars2;
            lineArray = []; // e.g. lineArray[4] === &#x27;Hello\n&#x27;
            lineHash = {}; // e.g. lineHash[&#x27;Hello\n&#x27;] === 4

            // &#x27;\x00&#x27; is a valid character, but various debuggers don&#x27;t like it.
            // So we&#x27;ll insert a junk entry to avoid generating a null character.
            lineArray[ 0 ] = &quot;&quot;;

            /**
             * Split a text into an array of strings.  Reduce the texts to a string of
             * hashes where each Unicode character represents one line.
             * Modifies linearray and linehash through being a closure.
             * @param {string} text String to encode.
             * @return {string} Encoded string.
             * @private
             */
            function diffLinesToCharsMunge( text ) {
                var chars, lineStart, lineEnd, lineArrayLength, line;
                chars = &quot;&quot;;
                // Walk the text, pulling out a substring for each line.
                // text.split(&#x27;\n&#x27;) would would temporarily double our memory footprint.
                // Modifying text would create many large strings to garbage collect.
                lineStart = 0;
                lineEnd = -1;
                // Keeping our own length variable is faster than looking it up.
                lineArrayLength = lineArray.length;
                while ( lineEnd &lt; text.length - 1 ) {
                    lineEnd = text.indexOf( &quot;\n&quot;, lineStart );
                    if ( lineEnd === -1 ) {
                        lineEnd = text.length - 1;
                    }
                    line = text.substring( lineStart, lineEnd + 1 );
                    lineStart = lineEnd + 1;

                    if ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :
                            ( lineHash[ line ] !== undefined ) ) {
                        chars += String.fromCharCode( lineHash[ line ] );
                    } else {
                        chars += String.fromCharCode( lineArrayLength );
                        lineHash[ line ] = lineArrayLength;
                        lineArray[ lineArrayLength++ ] = line;
                    }
                }
                return chars;
            }

            chars1 = diffLinesToCharsMunge( text1 );
            chars2 = diffLinesToCharsMunge( text2 );
            return {
                chars1: chars1,
                chars2: chars2,
                lineArray: lineArray
            };
        };

        /**
         * Rehydrate the text in a diff from a string of line hashes to real lines of
         * text.
         * @param {!Array.&lt;!DiffMatchPatch.Diff&gt;} diffs Array of diff tuples.
         * @param {!Array.&lt;string&gt;} lineArray Array of unique strings.
         * @private
         */
        DiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {
            var x, chars, text, y;
            for ( x = 0; x &lt; diffs.length; x++ ) {
                chars = diffs[ x ][ 1 ];
                text = [];
                for ( y = 0; y &lt; chars.length; y++ ) {
                    text[ y ] = lineArray[ chars.charCodeAt( y ) ];
                }
                diffs[ x ][ 1 ] = text.join( &quot;&quot; );
            }
        };

        /**
         * Reorder and merge like edit sections.  Merge equalities.
         * Any edit section can move as long as it doesn&#x27;t cross an equality.
         * @param {!Array.&lt;!DiffMatchPatch.Diff&gt;} diffs Array of diff tuples.
         */
        DiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {
            var pointer, countDelete, countInsert, textInsert, textDelete,
                commonlength, changes, diffPointer, position;
            diffs.push( [ DIFF_EQUAL, &quot;&quot; ] ); // Add a dummy entry at the end.
            pointer = 0;
            countDelete = 0;
            countInsert = 0;
            textDelete = &quot;&quot;;
            textInsert = &quot;&quot;;
            commonlength;
            while ( pointer &lt; diffs.length ) {
                switch ( diffs[ pointer ][ 0 ] ) {
                    case DIFF_INSERT:
                        countInsert++;
                        textInsert += diffs[ pointer ][ 1 ];
                        pointer++;
                        break;
                    case DIFF_DELETE:
                        countDelete++;
                        textDelete += diffs[ pointer ][ 1 ];
                        pointer++;
                        break;
                    case DIFF_EQUAL:
                        // Upon reaching an equality, check for prior redundancies.
                        if ( countDelete + countInsert &gt; 1 ) {
                            if ( countDelete !== 0 &amp;&amp; countInsert !== 0 ) {
                                // Factor out any common prefixes.
                                commonlength = this.diffCommonPrefix( textInsert, textDelete );
                                if ( commonlength !== 0 ) {
                                    if ( ( pointer - countDelete - countInsert ) &gt; 0 &amp;&amp;
                                        diffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===
                                        DIFF_EQUAL ) {
                                        diffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=
                                            textInsert.substring( 0, commonlength );
                                    } else {
                                        diffs.splice( 0, 0, [ DIFF_EQUAL,
                                            textInsert.substring( 0, commonlength )
                                        ] );
                                        pointer++;
                                    }
                                    textInsert = textInsert.substring( commonlength );
                                    textDelete = textDelete.substring( commonlength );
                                }
                                // Factor out any common suffixies.
                                commonlength = this.diffCommonSuffix( textInsert, textDelete );
                                if ( commonlength !== 0 ) {
                                    diffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -
                                            commonlength ) + diffs[ pointer ][ 1 ];
                                    textInsert = textInsert.substring( 0, textInsert.length -
                                        commonlength );
                                    textDelete = textDelete.substring( 0, textDelete.length -
                                        commonlength );
                                }
                            }
                            // Delete the offending records and add the merged ones.
                            if ( countDelete === 0 ) {
                                diffs.splice( pointer - countInsert,
                                    countDelete + countInsert, [ DIFF_INSERT, textInsert ] );
                            } else if ( countInsert === 0 ) {
                                diffs.splice( pointer - countDelete,
                                    countDelete + countInsert, [ DIFF_DELETE, textDelete ] );
                            } else {
                                diffs.splice(
                                    pointer - countDelete - countInsert,
                                    countDelete + countInsert,
                                    [ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]
                                );
                            }
                            pointer = pointer - countDelete - countInsert +
                                ( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;
                        } else if ( pointer !== 0 &amp;&amp; diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {

                            // Merge this equality with the previous one.
                            diffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];
                            diffs.splice( pointer, 1 );
                        } else {
                            pointer++;
                        }
                        countInsert = 0;
                        countDelete = 0;
                        textDelete = &quot;&quot;;
                        textInsert = &quot;&quot;;
                        break;
                }
            }
            if ( diffs[ diffs.length - 1 ][ 1 ] === &quot;&quot; ) {
                diffs.pop(); // Remove the dummy entry at the end.
            }

            // Second pass: look for single edits surrounded on both sides by equalities
            // which can be shifted sideways to eliminate an equality.
            // e.g: A&lt;ins&gt;BA&lt;/ins&gt;C -&gt; &lt;ins&gt;AB&lt;/ins&gt;AC
            changes = false;
            pointer = 1;

            // Intentionally ignore the first and last element (don&#x27;t need checking).
            while ( pointer &lt; diffs.length - 1 ) {
                if ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &amp;&amp;
                    diffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {

                    diffPointer = diffs[ pointer ][ 1 ];
                    position = diffPointer.substring(
                        diffPointer.length - diffs[ pointer - 1 ][ 1 ].length
                    );

                    // This is a single edit surrounded by equalities.
                    if ( position === diffs[ pointer - 1 ][ 1 ] ) {

                        // Shift the edit over the previous equality.
                        diffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +
                            diffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -
                                diffs[ pointer - 1 ][ 1 ].length );
                        diffs[ pointer + 1 ][ 1 ] =
                            diffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];
                        diffs.splice( pointer - 1, 1 );
                        changes = true;
                    } else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===
                        diffs[ pointer + 1 ][ 1 ] ) {

                        // Shift the edit over the next equality.
                        diffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];
                        diffs[ pointer ][ 1 ] =
                            diffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +
                            diffs[ pointer + 1 ][ 1 ];
                        diffs.splice( pointer + 1, 1 );
                        changes = true;
                    }
                }
                pointer++;
            }
            // If shifts were made, the diff needs reordering and another shift sweep.
            if ( changes ) {
                this.diffCleanupMerge( diffs );
            }
        };

        return function( o, n ) {
            var diff, output, text;
            diff = new DiffMatchPatch();
            output = diff.DiffMain( o, n );
            diff.diffCleanupEfficiency( output );
            text = diff.diffPrettyHtml( output );

            return text;
        };
    }() );

// Get a reference to the global object, like window in browsers
}( (function() {
    return this;
})() ));

(function() {

// Don&#x27;t load the HTML Reporter on non-Browser environments
    if ( typeof window === &quot;undefined&quot; || !window.document ) {
        return;
    }

// Deprecated QUnit.init - Ref #530
// Re-initialize the configuration options
    QUnit.init = function() {
        var tests, banner, result, qunit,
            config = QUnit.config;

        config.stats = { all: 0, bad: 0 };
        config.moduleStats = { all: 0, bad: 0 };
        config.started = 0;
        config.updateRate = 1000;
        config.blocking = false;
        config.autostart = true;
        config.autorun = false;
        config.filter = &quot;&quot;;
        config.queue = [];

        // Return on non-browser environments
        // This is necessary to not break on node tests
        if ( typeof window === &quot;undefined&quot; ) {
            return;
        }

        qunit = id( &quot;qunit&quot; );
        if ( qunit ) {
            qunit.innerHTML =
                &quot;&lt;h1 id=&#x27;qunit-header&#x27;&gt;&quot; + escapeText( document.title ) + &quot;&lt;/h1&gt;&quot; +
                &quot;&lt;h2 id=&#x27;qunit-banner&#x27;&gt;&lt;/h2&gt;&quot; +
                &quot;&lt;div id=&#x27;qunit-testrunner-toolbar&#x27;&gt;&lt;/div&gt;&quot; +
                &quot;&lt;h2 id=&#x27;qunit-userAgent&#x27;&gt;&lt;/h2&gt;&quot; +
                &quot;&lt;ol id=&#x27;qunit-tests&#x27;&gt;&lt;/ol&gt;&quot;;
        }

        tests = id( &quot;qunit-tests&quot; );
        banner = id( &quot;qunit-banner&quot; );
        result = id( &quot;qunit-testresult&quot; );

        if ( tests ) {
            tests.innerHTML = &quot;&quot;;
        }

        if ( banner ) {
            banner.className = &quot;&quot;;
        }

        if ( result ) {
            result.parentNode.removeChild( result );
        }

        if ( tests ) {
            result = document.createElement( &quot;p&quot; );
            result.id = &quot;qunit-testresult&quot;;
            result.className = &quot;result&quot;;
            tests.parentNode.insertBefore( result, tests );
            result.innerHTML = &quot;Running...&lt;br /&gt;&amp;#160;&quot;;
        }
    };

    var config = QUnit.config,
        collapseNext = false,
        hasOwn = Object.prototype.hasOwnProperty,
        defined = {
            document: window.document !== undefined,
            sessionStorage: (function() {
                var x = &quot;qunit-test-string&quot;;
                try {
                    sessionStorage.setItem( x, x );
                    sessionStorage.removeItem( x );
                    return true;
                } catch ( e ) {
                    return false;
                }
            }())
        },
        modulesList = [];

    /**
     * Escape text for attribute or text content.
     */
    function escapeText( s ) {
        if ( !s ) {
            return &quot;&quot;;
        }
        s = s + &quot;&quot;;

        // Both single quotes and double quotes (for attributes)
        return s.replace( /[&#x27;&quot;&lt;&gt;&amp;]/g, function( s ) {
            switch ( s ) {
                case &quot;&#x27;&quot;:
                    return &quot;&amp;#039;&quot;;
                case &quot;\&quot;&quot;:
                    return &quot;&amp;quot;&quot;;
                case &quot;&lt;&quot;:
                    return &quot;&amp;lt;&quot;;
                case &quot;&gt;&quot;:
                    return &quot;&amp;gt;&quot;;
                case &quot;&amp;&quot;:
                    return &quot;&amp;amp;&quot;;
            }
        });
    }

    /**
     * @param {HTMLElement} elem
     * @param {string} type
     * @param {Function} fn
     */
    function addEvent( elem, type, fn ) {
        if ( elem.addEventListener ) {

            // Standards-based browsers
            elem.addEventListener( type, fn, false );
        } else if ( elem.attachEvent ) {

            // support: IE &lt;9
            elem.attachEvent( &quot;on&quot; + type, function() {
                var event = window.event;
                if ( !event.target ) {
                    event.target = event.srcElement || document;
                }

                fn.call( elem, event );
            });
        }
    }

    /**
     * @param {Array|NodeList} elems
     * @param {string} type
     * @param {Function} fn
     */
    function addEvents( elems, type, fn ) {
        var i = elems.length;
        while ( i-- ) {
            addEvent( elems[ i ], type, fn );
        }
    }

    function hasClass( elem, name ) {
        return ( &quot; &quot; + elem.className + &quot; &quot; ).indexOf( &quot; &quot; + name + &quot; &quot; ) &gt;= 0;
    }

    function addClass( elem, name ) {
        if ( !hasClass( elem, name ) ) {
            elem.className += ( elem.className ? &quot; &quot; : &quot;&quot; ) + name;
        }
    }

    function toggleClass( elem, name ) {
        if ( hasClass( elem, name ) ) {
            removeClass( elem, name );
        } else {
            addClass( elem, name );
        }
    }

    function removeClass( elem, name ) {
        var set = &quot; &quot; + elem.className + &quot; &quot;;

        // Class name may appear multiple times
        while ( set.indexOf( &quot; &quot; + name + &quot; &quot; ) &gt;= 0 ) {
            set = set.replace( &quot; &quot; + name + &quot; &quot;, &quot; &quot; );
        }

        // trim for prettiness
        elem.className = typeof set.trim === &quot;function&quot; ? set.trim() : set.replace( /^\s+|\s+$/g, &quot;&quot; );
    }

    function id( name ) {
        return defined.document &amp;&amp; document.getElementById &amp;&amp; document.getElementById( name );
    }

    function getUrlConfigHtml() {
        var i, j, val,
            escaped, escapedTooltip,
            selection = false,
            len = config.urlConfig.length,
            urlConfigHtml = &quot;&quot;;

        for ( i = 0; i &lt; len; i++ ) {
            val = config.urlConfig[ i ];
            if ( typeof val === &quot;string&quot; ) {
                val = {
                    id: val,
                    label: val
                };
            }

            escaped = escapeText( val.id );
            escapedTooltip = escapeText( val.tooltip );

            if ( config[ val.id ] === undefined ) {
                config[ val.id ] = QUnit.urlParams[ val.id ];
            }

            if ( !val.value || typeof val.value === &quot;string&quot; ) {
                urlConfigHtml += &quot;&lt;input id=&#x27;qunit-urlconfig-&quot; + escaped +
                    &quot;&#x27; name=&#x27;&quot; + escaped + &quot;&#x27; type=&#x27;checkbox&#x27;&quot; +
                    ( val.value ? &quot; value=&#x27;&quot; + escapeText( val.value ) + &quot;&#x27;&quot; : &quot;&quot; ) +
                    ( config[ val.id ] ? &quot; checked=&#x27;checked&#x27;&quot; : &quot;&quot; ) +
                    &quot; title=&#x27;&quot; + escapedTooltip + &quot;&#x27; /&gt;&lt;label for=&#x27;qunit-urlconfig-&quot; + escaped +
                    &quot;&#x27; title=&#x27;&quot; + escapedTooltip + &quot;&#x27;&gt;&quot; + val.label + &quot;&lt;/label&gt;&quot;;
            } else {
                urlConfigHtml += &quot;&lt;label for=&#x27;qunit-urlconfig-&quot; + escaped +
                    &quot;&#x27; title=&#x27;&quot; + escapedTooltip + &quot;&#x27;&gt;&quot; + val.label +
                    &quot;: &lt;/label&gt;&lt;select id=&#x27;qunit-urlconfig-&quot; + escaped +
                    &quot;&#x27; name=&#x27;&quot; + escaped + &quot;&#x27; title=&#x27;&quot; + escapedTooltip + &quot;&#x27;&gt;&lt;option&gt;&lt;/option&gt;&quot;;

                if ( QUnit.is( &quot;array&quot;, val.value ) ) {
                    for ( j = 0; j &lt; val.value.length; j++ ) {
                        escaped = escapeText( val.value[ j ] );
                        urlConfigHtml += &quot;&lt;option value=&#x27;&quot; + escaped + &quot;&#x27;&quot; +
                            ( config[ val.id ] === val.value[ j ] ?
                            ( selection = true ) &amp;&amp; &quot; selected=&#x27;selected&#x27;&quot; : &quot;&quot; ) +
                            &quot;&gt;&quot; + escaped + &quot;&lt;/option&gt;&quot;;
                    }
                } else {
                    for ( j in val.value ) {
                        if ( hasOwn.call( val.value, j ) ) {
                            urlConfigHtml += &quot;&lt;option value=&#x27;&quot; + escapeText( j ) + &quot;&#x27;&quot; +
                                ( config[ val.id ] === j ?
                                ( selection = true ) &amp;&amp; &quot; selected=&#x27;selected&#x27;&quot; : &quot;&quot; ) +
                                &quot;&gt;&quot; + escapeText( val.value[ j ] ) + &quot;&lt;/option&gt;&quot;;
                        }
                    }
                }
                if ( config[ val.id ] &amp;&amp; !selection ) {
                    escaped = escapeText( config[ val.id ] );
                    urlConfigHtml += &quot;&lt;option value=&#x27;&quot; + escaped +
                        &quot;&#x27; selected=&#x27;selected&#x27; disabled=&#x27;disabled&#x27;&gt;&quot; + escaped + &quot;&lt;/option&gt;&quot;;
                }
                urlConfigHtml += &quot;&lt;/select&gt;&quot;;
            }
        }

        return urlConfigHtml;
    }

// Handle &quot;click&quot; events on toolbar checkboxes and &quot;change&quot; for select menus.
// Updates the URL with the new state of &#x60;config.urlConfig&#x60; values.
    function toolbarChanged() {
        var updatedUrl, value,
            field = this,
            params = {};

        // Detect if field is a select menu or a checkbox
        if ( &quot;selectedIndex&quot; in field ) {
            value = field.options[ field.selectedIndex ].value || undefined;
        } else {
            value = field.checked ? ( field.defaultValue || true ) : undefined;
        }

        params[ field.name ] = value;
        updatedUrl = setUrl( params );

        if ( &quot;hidepassed&quot; === field.name &amp;&amp; &quot;replaceState&quot; in window.history ) {
            config[ field.name ] = value || false;
            if ( value ) {
                addClass( id( &quot;qunit-tests&quot; ), &quot;hidepass&quot; );
            } else {
                removeClass( id( &quot;qunit-tests&quot; ), &quot;hidepass&quot; );
            }

            // It is not necessary to refresh the whole page
            window.history.replaceState( null, &quot;&quot;, updatedUrl );
        } else {
            window.location = updatedUrl;
        }
    }

    function setUrl( params ) {
        var key,
            querystring = &quot;?&quot;;

        params = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );

        for ( key in params ) {
            if ( hasOwn.call( params, key ) ) {
                if ( params[ key ] === undefined ) {
                    continue;
                }
                querystring += encodeURIComponent( key );
                if ( params[ key ] !== true ) {
                    querystring += &quot;=&quot; + encodeURIComponent( params[ key ] );
                }
                querystring += &quot;&amp;&quot;;
            }
        }
        return location.protocol + &quot;//&quot; + location.host +
            location.pathname + querystring.slice( 0, -1 );
    }

    function applyUrlParams() {
        var selectedModule,
            modulesList = id( &quot;qunit-modulefilter&quot; ),
            filter = id( &quot;qunit-filter-input&quot; ).value;

        selectedModule = modulesList ?
            decodeURIComponent( modulesList.options[ modulesList.selectedIndex ].value ) :
            undefined;

        window.location = setUrl({
            module: ( selectedModule === &quot;&quot; ) ? undefined : selectedModule,
            filter: ( filter === &quot;&quot; ) ? undefined : filter,

            // Remove testId filter
            testId: undefined
        });
    }

    function toolbarUrlConfigContainer() {
        var urlConfigContainer = document.createElement( &quot;span&quot; );

        urlConfigContainer.innerHTML = getUrlConfigHtml();
        addClass( urlConfigContainer, &quot;qunit-url-config&quot; );

        // For oldIE support:
        // * Add handlers to the individual elements instead of the container
        // * Use &quot;click&quot; instead of &quot;change&quot; for checkboxes
        addEvents( urlConfigContainer.getElementsByTagName( &quot;input&quot; ), &quot;click&quot;, toolbarChanged );
        addEvents( urlConfigContainer.getElementsByTagName( &quot;select&quot; ), &quot;change&quot;, toolbarChanged );

        return urlConfigContainer;
    }

    function toolbarLooseFilter() {
        var filter = document.createElement( &quot;form&quot; ),
            label = document.createElement( &quot;label&quot; ),
            input = document.createElement( &quot;input&quot; ),
            button = document.createElement( &quot;button&quot; );

        addClass( filter, &quot;qunit-filter&quot; );

        label.innerHTML = &quot;Filter: &quot;;

        input.type = &quot;text&quot;;
        input.value = config.filter || &quot;&quot;;
        input.name = &quot;filter&quot;;
        input.id = &quot;qunit-filter-input&quot;;

        button.innerHTML = &quot;Go&quot;;

        label.appendChild( input );

        filter.appendChild( label );
        filter.appendChild( button );
        addEvent( filter, &quot;submit&quot;, function( ev ) {
            applyUrlParams();

            if ( ev &amp;&amp; ev.preventDefault ) {
                ev.preventDefault();
            }

            return false;
        });

        return filter;
    }

    function toolbarModuleFilterHtml() {
        var i,
            moduleFilterHtml = &quot;&quot;;

        if ( !modulesList.length ) {
            return false;
        }

        modulesList.sort(function( a, b ) {
            return a.localeCompare( b );
        });

        moduleFilterHtml += &quot;&lt;label for=&#x27;qunit-modulefilter&#x27;&gt;Module: &lt;/label&gt;&quot; +
            &quot;&lt;select id=&#x27;qunit-modulefilter&#x27; name=&#x27;modulefilter&#x27;&gt;&lt;option value=&#x27;&#x27; &quot; +
            ( QUnit.urlParams.module === undefined ? &quot;selected=&#x27;selected&#x27;&quot; : &quot;&quot; ) +
            &quot;&gt;&lt; All Modules &gt;&lt;/option&gt;&quot;;

        for ( i = 0; i &lt; modulesList.length; i++ ) {
            moduleFilterHtml += &quot;&lt;option value=&#x27;&quot; +
                escapeText( encodeURIComponent( modulesList[ i ] ) ) + &quot;&#x27; &quot; +
                ( QUnit.urlParams.module === modulesList[ i ] ? &quot;selected=&#x27;selected&#x27;&quot; : &quot;&quot; ) +
                &quot;&gt;&quot; + escapeText( modulesList[ i ] ) + &quot;&lt;/option&gt;&quot;;
        }
        moduleFilterHtml += &quot;&lt;/select&gt;&quot;;

        return moduleFilterHtml;
    }

    function toolbarModuleFilter() {
        var toolbar = id( &quot;qunit-testrunner-toolbar&quot; ),
            moduleFilter = document.createElement( &quot;span&quot; ),
            moduleFilterHtml = toolbarModuleFilterHtml();

        if ( !toolbar || !moduleFilterHtml ) {
            return false;
        }

        moduleFilter.setAttribute( &quot;id&quot;, &quot;qunit-modulefilter-container&quot; );
        moduleFilter.innerHTML = moduleFilterHtml;

        addEvent( moduleFilter.lastChild, &quot;change&quot;, applyUrlParams );

        toolbar.appendChild( moduleFilter );
    }

    function appendToolbar() {
        var toolbar = id( &quot;qunit-testrunner-toolbar&quot; );

        if ( toolbar ) {
            toolbar.appendChild( toolbarUrlConfigContainer() );
            toolbar.appendChild( toolbarLooseFilter() );
        }
    }

    function appendHeader() {
        var header = id( &quot;qunit-header&quot; );

        if ( header ) {
            header.innerHTML = &quot;&lt;a href=&#x27;&quot; +
                escapeText( setUrl( { filter: undefined, module: undefined, testId: undefined } ) ) +
                &quot;&#x27;&gt;&quot; + header.innerHTML + &quot;&lt;/a&gt; &quot;;
        }
    }

    function appendBanner() {
        var banner = id( &quot;qunit-banner&quot; );

        if ( banner ) {
            banner.className = &quot;&quot;;
        }
    }

    function appendTestResults() {
        var tests = id( &quot;qunit-tests&quot; ),
            result = id( &quot;qunit-testresult&quot; );

        if ( result ) {
            result.parentNode.removeChild( result );
        }

        if ( tests ) {
            tests.innerHTML = &quot;&quot;;
            result = document.createElement( &quot;p&quot; );
            result.id = &quot;qunit-testresult&quot;;
            result.className = &quot;result&quot;;
            tests.parentNode.insertBefore( result, tests );
            result.innerHTML = &quot;Running...&lt;br /&gt;&amp;#160;&quot;;
        }
    }

    function storeFixture() {
        var fixture = id( &quot;qunit-fixture&quot; );
        if ( fixture ) {
            config.fixture = fixture.innerHTML;
        }
    }

    function appendFilteredTest() {
        var testId = QUnit.config.testId;
        if ( !testId || testId.length &lt;= 0 ) {
            return &quot;&quot;;
        }
        return &quot;&lt;div id=&#x27;qunit-filteredTest&#x27;&gt;Rerunning selected tests: &quot; +
            escapeText( testId.join(&quot;, &quot;) ) +
            &quot; &lt;a id=&#x27;qunit-clearFilter&#x27; href=&#x27;&quot; +
            escapeText( setUrl( { filter: undefined, module: undefined, testId: undefined } ) ) +
            &quot;&#x27;&gt;&quot; + &quot;Run all tests&quot; + &quot;&lt;/a&gt;&lt;/div&gt;&quot;;
    }

    function appendUserAgent() {
        var userAgent = id( &quot;qunit-userAgent&quot; );

        if ( userAgent ) {
            userAgent.innerHTML = &quot;&quot;;
            userAgent.appendChild(
                document.createTextNode(
                    &quot;QUnit &quot; + QUnit.version + &quot;; &quot; + navigator.userAgent
                )
            );
        }
    }

    function appendTestsList( modules ) {
        var i, l, x, z, test, moduleObj;

        for ( i = 0, l = modules.length; i &lt; l; i++ ) {
            moduleObj = modules[ i ];

            if ( moduleObj.name ) {
                modulesList.push( moduleObj.name );
            }

            for ( x = 0, z = moduleObj.tests.length; x &lt; z; x++ ) {
                test = moduleObj.tests[ x ];

                appendTest( test.name, test.testId, moduleObj.name );
            }
        }
    }

    function appendTest( name, testId, moduleName ) {
        var title, rerunTrigger, testBlock, assertList,
            tests = id( &quot;qunit-tests&quot; );

        if ( !tests ) {
            return;
        }

        title = document.createElement( &quot;strong&quot; );
        title.innerHTML = getNameHtml( name, moduleName );

        rerunTrigger = document.createElement( &quot;a&quot; );
        rerunTrigger.innerHTML = &quot;Rerun&quot;;
        rerunTrigger.href = setUrl({ testId: testId });

        testBlock = document.createElement( &quot;li&quot; );
        testBlock.appendChild( title );
        testBlock.appendChild( rerunTrigger );
        testBlock.id = &quot;qunit-test-output-&quot; + testId;

        assertList = document.createElement( &quot;ol&quot; );
        assertList.className = &quot;qunit-assert-list&quot;;

        testBlock.appendChild( assertList );

        tests.appendChild( testBlock );
    }

// HTML Reporter initialization and load
    QUnit.begin(function( details ) {
        var qunit = id( &quot;qunit&quot; );

        // Fixture is the only one necessary to run without the #qunit element
        storeFixture();

        if ( qunit ) {
            qunit.innerHTML =
                &quot;&lt;h1 id=&#x27;qunit-header&#x27;&gt;&quot; + escapeText( document.title ) + &quot;&lt;/h1&gt;&quot; +
                &quot;&lt;h2 id=&#x27;qunit-banner&#x27;&gt;&lt;/h2&gt;&quot; +
                &quot;&lt;div id=&#x27;qunit-testrunner-toolbar&#x27;&gt;&lt;/div&gt;&quot; +
                appendFilteredTest() +
                &quot;&lt;h2 id=&#x27;qunit-userAgent&#x27;&gt;&lt;/h2&gt;&quot; +
                &quot;&lt;ol id=&#x27;qunit-tests&#x27;&gt;&lt;/ol&gt;&quot;;
        }

        appendHeader();
        appendBanner();
        appendTestResults();
        appendUserAgent();
        appendToolbar();
        appendTestsList( details.modules );
        toolbarModuleFilter();

        if ( qunit &amp;&amp; config.hidepassed ) {
            addClass( qunit.lastChild, &quot;hidepass&quot; );
        }
    });

    QUnit.done(function( details ) {
        var i, key,
            banner = id( &quot;qunit-banner&quot; ),
            tests = id( &quot;qunit-tests&quot; ),
            html = [
                &quot;Tests completed in &quot;,
                details.runtime,
                &quot; milliseconds.&lt;br /&gt;&quot;,
                &quot;&lt;span class=&#x27;passed&#x27;&gt;&quot;,
                details.passed,
                &quot;&lt;/span&gt; assertions of &lt;span class=&#x27;total&#x27;&gt;&quot;,
                details.total,
                &quot;&lt;/span&gt; passed, &lt;span class=&#x27;failed&#x27;&gt;&quot;,
                details.failed,
                &quot;&lt;/span&gt; failed.&quot;
            ].join( &quot;&quot; );

        if ( banner ) {
            banner.className = details.failed ? &quot;qunit-fail&quot; : &quot;qunit-pass&quot;;
        }

        if ( tests ) {
            id( &quot;qunit-testresult&quot; ).innerHTML = html;
        }

        if ( config.altertitle &amp;&amp; defined.document &amp;&amp; document.title ) {

            // show ✖ for good, ✔ for bad suite result in title
            // use escape sequences in case file gets loaded with non-utf-8-charset
            document.title = [
                ( details.failed ? &quot;\u2716&quot; : &quot;\u2714&quot; ),
                document.title.replace( /^[\u2714\u2716] /i, &quot;&quot; )
            ].join( &quot; &quot; );
        }

        // clear own sessionStorage items if all tests passed
        if ( config.reorder &amp;&amp; defined.sessionStorage &amp;&amp; details.failed === 0 ) {
            for ( i = 0; i &lt; sessionStorage.length; i++ ) {
                key = sessionStorage.key( i++ );
                if ( key.indexOf( &quot;qunit-test-&quot; ) === 0 ) {
                    sessionStorage.removeItem( key );
                }
            }
        }

        // scroll back to top to show results
        if ( config.scrolltop &amp;&amp; window.scrollTo ) {
            window.scrollTo( 0, 0 );
        }
    });

    function getNameHtml( name, module ) {
        var nameHtml = &quot;&quot;;

        if ( module ) {
            nameHtml = &quot;&lt;span class=&#x27;module-name&#x27;&gt;&quot; + escapeText( module ) + &quot;&lt;/span&gt;: &quot;;
        }

        nameHtml += &quot;&lt;span class=&#x27;test-name&#x27;&gt;&quot; + escapeText( name ) + &quot;&lt;/span&gt;&quot;;

        return nameHtml;
    }

    QUnit.testStart(function( details ) {
        var running, testBlock, bad;

        testBlock = id( &quot;qunit-test-output-&quot; + details.testId );
        if ( testBlock ) {
            testBlock.className = &quot;running&quot;;
        } else {

            // Report later registered tests
            appendTest( details.name, details.testId, details.module );
        }

        running = id( &quot;qunit-testresult&quot; );
        if ( running ) {
            bad = QUnit.config.reorder &amp;&amp; defined.sessionStorage &amp;&amp;
                +sessionStorage.getItem( &quot;qunit-test-&quot; + details.module + &quot;-&quot; + details.name );

            running.innerHTML = ( bad ?
                    &quot;Rerunning previously failed test: &lt;br /&gt;&quot; :
                    &quot;Running: &lt;br /&gt;&quot; ) +
                getNameHtml( details.name, details.module );
        }

    });

    function stripHtml( string ) {
        // strip tags, html entity and whitespaces
        return string.replace(/&lt;\/?[^&gt;]+(&gt;|$)/g, &quot;&quot;).replace(/\&amp;quot;/g, &quot;&quot;).replace(/\s+/g, &quot;&quot;);
    }

    QUnit.log(function( details ) {
        var assertList, assertLi,
            message, expected, actual, diff,
            showDiff = false,
            testItem = id( &quot;qunit-test-output-&quot; + details.testId );

        if ( !testItem ) {
            return;
        }

        message = escapeText( details.message ) || ( details.result ? &quot;okay&quot; : &quot;failed&quot; );
        message = &quot;&lt;span class=&#x27;test-message&#x27;&gt;&quot; + message + &quot;&lt;/span&gt;&quot;;
        message += &quot;&lt;span class=&#x27;runtime&#x27;&gt;@ &quot; + details.runtime + &quot; ms&lt;/span&gt;&quot;;

        // pushFailure doesn&#x27;t provide details.expected
        // when it calls, it&#x27;s implicit to also not show expected and diff stuff
        // Also, we need to check details.expected existence, as it can exist and be undefined
        if ( !details.result &amp;&amp; hasOwn.call( details, &quot;expected&quot; ) ) {
            if ( details.negative ) {
                expected = escapeText( &quot;NOT &quot; + QUnit.dump.parse( details.expected ) );
            } else {
                expected = escapeText( QUnit.dump.parse( details.expected ) );
            }

            actual = escapeText( QUnit.dump.parse( details.actual ) );
            message += &quot;&lt;table&gt;&lt;tr class=&#x27;test-expected&#x27;&gt;&lt;th&gt;Expected: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&quot; +
                expected +
                &quot;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;

            if ( actual !== expected ) {

                message += &quot;&lt;tr class=&#x27;test-actual&#x27;&gt;&lt;th&gt;Result: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&quot; +
                    actual + &quot;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;

                // Don&#x27;t show diff if actual or expected are booleans
                if ( !( /^(true|false)$/.test( actual ) ) &amp;&amp;
                    !( /^(true|false)$/.test( expected ) ) ) {
                    diff = QUnit.diff( expected, actual );
                    showDiff = stripHtml( diff ).length !==
                        stripHtml( expected ).length +
                        stripHtml( actual ).length;
                }

                // Don&#x27;t show diff if expected and actual are totally different
                if ( showDiff ) {
                    message += &quot;&lt;tr class=&#x27;test-diff&#x27;&gt;&lt;th&gt;Diff: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&quot; +
                        diff + &quot;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;
                }
            } else if ( expected.indexOf( &quot;[object Array]&quot; ) !== -1 ||
                expected.indexOf( &quot;[object Object]&quot; ) !== -1 ) {
                message += &quot;&lt;tr class=&#x27;test-message&#x27;&gt;&lt;th&gt;Message: &lt;/th&gt;&lt;td&gt;&quot; +
                    &quot;Diff suppressed as the depth of object is more than current max depth (&quot; +
                    QUnit.config.maxDepth + &quot;).&lt;p&gt;Hint: Use &lt;code&gt;QUnit.dump.maxDepth&lt;/code&gt; to &quot; +
                    &quot; run with a higher max depth or &lt;a href=&#x27;&quot; +
                    escapeText( setUrl( { maxDepth: -1 } ) ) + &quot;&#x27;&gt;&quot; +
                    &quot;Rerun&lt;/a&gt; without max depth.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;
            }

            if ( details.source ) {
                message += &quot;&lt;tr class=&#x27;test-source&#x27;&gt;&lt;th&gt;Source: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&quot; +
                    escapeText( details.source ) + &quot;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;
            }

            message += &quot;&lt;/table&gt;&quot;;

            // this occurs when pushFailure is set and we have an extracted stack trace
        } else if ( !details.result &amp;&amp; details.source ) {
            message += &quot;&lt;table&gt;&quot; +
                &quot;&lt;tr class=&#x27;test-source&#x27;&gt;&lt;th&gt;Source: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&quot; +
                escapeText( details.source ) + &quot;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
                &quot;&lt;/table&gt;&quot;;
        }

        assertList = testItem.getElementsByTagName( &quot;ol&quot; )[ 0 ];

        assertLi = document.createElement( &quot;li&quot; );
        assertLi.className = details.result ? &quot;pass&quot; : &quot;fail&quot;;
        assertLi.innerHTML = message;
        assertList.appendChild( assertLi );
    });

    QUnit.testDone(function( details ) {
        var testTitle, time, testItem, assertList,
            good, bad, testCounts, skipped, sourceName,
            tests = id( &quot;qunit-tests&quot; );

        if ( !tests ) {
            return;
        }

        testItem = id( &quot;qunit-test-output-&quot; + details.testId );

        assertList = testItem.getElementsByTagName( &quot;ol&quot; )[ 0 ];

        good = details.passed;
        bad = details.failed;

        // store result when possible
        if ( config.reorder &amp;&amp; defined.sessionStorage ) {
            if ( bad ) {
                sessionStorage.setItem( &quot;qunit-test-&quot; + details.module + &quot;-&quot; + details.name, bad );
            } else {
                sessionStorage.removeItem( &quot;qunit-test-&quot; + details.module + &quot;-&quot; + details.name );
            }
        }

        if ( bad === 0 ) {

            // Collapse the passing tests
            addClass( assertList, &quot;qunit-collapsed&quot; );
        } else if ( bad &amp;&amp; config.collapse &amp;&amp; !collapseNext ) {

            // Skip collapsing the first failing test
            collapseNext = true;
        } else {

            // Collapse remaining tests
            addClass( assertList, &quot;qunit-collapsed&quot; );
        }

        // testItem.firstChild is the test name
        testTitle = testItem.firstChild;

        testCounts = bad ?
        &quot;&lt;b class=&#x27;failed&#x27;&gt;&quot; + bad + &quot;&lt;/b&gt;, &quot; + &quot;&lt;b class=&#x27;passed&#x27;&gt;&quot; + good + &quot;&lt;/b&gt;, &quot; :
            &quot;&quot;;

        testTitle.innerHTML += &quot; &lt;b class=&#x27;counts&#x27;&gt;(&quot; + testCounts +
            details.assertions.length + &quot;)&lt;/b&gt;&quot;;

        if ( details.skipped ) {
            testItem.className = &quot;skipped&quot;;
            skipped = document.createElement( &quot;em&quot; );
            skipped.className = &quot;qunit-skipped-label&quot;;
            skipped.innerHTML = &quot;skipped&quot;;
            testItem.insertBefore( skipped, testTitle );
        } else {
            addEvent( testTitle, &quot;click&quot;, function() {
                toggleClass( assertList, &quot;qunit-collapsed&quot; );
            });

            testItem.className = bad ? &quot;fail&quot; : &quot;pass&quot;;

            time = document.createElement( &quot;span&quot; );
            time.className = &quot;runtime&quot;;
            time.innerHTML = details.runtime + &quot; ms&quot;;
            testItem.insertBefore( time, assertList );
        }

        // Show the source of the test when showing assertions
        if ( details.source ) {
            sourceName = document.createElement( &quot;p&quot; );
            sourceName.innerHTML = &quot;&lt;strong&gt;Source: &lt;/strong&gt;&quot; + details.source;
            addClass( sourceName, &quot;qunit-source&quot; );
            if ( bad === 0 ) {
                addClass( sourceName, &quot;qunit-collapsed&quot; );
            }
            addEvent( testTitle, &quot;click&quot;, function() {
                toggleClass( sourceName, &quot;qunit-collapsed&quot; );
            });
            testItem.appendChild( sourceName );
        }
    });

    if ( defined.document ) {

        // Avoid readyState issue with phantomjs
        // Ref: #818
        var notPhantom = ( function( p ) {
            return !( p &amp;&amp; p.version &amp;&amp; p.version.major &gt; 0 );
        } )( window.phantom );

        if ( notPhantom &amp;&amp; document.readyState === &quot;complete&quot; ) {
            QUnit.load();
        } else {
            addEvent( window, &quot;load&quot;, QUnit.load );
        }
    } else {
        config.pageLoaded = true;
        config.autorun = true;
    }

})();
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
