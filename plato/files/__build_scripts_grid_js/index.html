<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - ./build/scripts/grid.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>./build/scripts/grid.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">55.08</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2765</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">194.63</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">60.57</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var grid = (function _grid($) {
    &#039;use strict&#039;;
    var dataTypes, events, storage, aggregates;

    function create(gridData, gridElem) {
        if (gridData &amp;&amp; isDomElement(gridElem)) {
            var id = storage.count;
            if (id &gt; 0) {   
                var tmp = id - 1;
                while (tmp &gt; -1) {  
                    if (storage.grids[tmp] != null &amp;&amp; !$(&#039;body&#039;).find(&#039;#&#039; + storage.grids[tmp].grid[0].id).length)     
                        delete storage.grids[tmp];      
                    tmp--;
                }
            }
            gridElem = $(gridElem);
            var wrapperDiv = $(&#039;&lt;div id=&quot;grid-wrapper-&#039; + id + &#039;&quot; data-grid_id=&quot;&#039; + id + &#039;&quot; class=grid-wrapper&gt;&lt;/div&gt;&#039;).appendTo(gridElem);
            var headerDiv = $(&#039;&lt;div id=&quot;grid-header-&#039; + id + &#039;&quot; data-grid_header_id=&quot;&#039; + id + &#039;&quot; class=grid-header-div&gt;&lt;/div&gt;&#039;).appendTo(wrapperDiv);
            headerDiv.append(&#039;&lt;div class=grid-header-wrapper&gt;&lt;/div&gt;&#039;);
            wrapperDiv.append(&#039;&lt;div id=&quot;grid-content-&#039; + id + &#039;&quot; data-grid_content_id=&quot;&#039; + id + &#039;&quot; class=grid-content-div&gt;&lt;/div&gt;&#039;);
            wrapperDiv.append(&#039;&lt;div id=&quot;grid-footer-&#039; + id + &#039;&quot; data-grid_footer_id=&quot;&#039; + id + &#039;&quot; class=grid-footer-div&gt;&lt;/div&gt;&#039;);

            storage.grids[id] = {};
            gridElem[0].grid = {};

            createGridInstanceMethods(gridElem, id);

            (gridData.useValidator === true &amp;&amp; window.validator &amp;&amp; typeof validator.setAdditionalEvents === &#039;function&#039;) ? validator.setAdditionalEvents([&#039;blur&#039;, &#039;change&#039;]) : gridData.useValidator = false;
            gridData.useFormatter = gridData.useFormatter === true &amp;&amp; window.formatter &amp;&amp; typeof formatter.getFormattedInput === &#039;function&#039;;

            if (gridData.constructor === Array) createGridColumnsFromArray(gridData, gridElem);
            else {
                createGridHeaders(gridData, gridElem);
                getInitialGridData(gridData.dataSource, function initialGridDataCallback(err, res) {
                    if (!err) {
                        gridData.dataSource.data = res.data;
                        gridData.dataSource.rowCount = res.rowCount || 25;
                        if (res.aggregations) {
                            for (var col in gridData.summaryRow) {
                                if (res.aggregations[col])
                                    gridData.summaryRow[col].value = res.aggregations[col];
                            }
                        }
                    }
                    else {
                        gridData.dataSource.data = {};
                        gridData.dataSource.rowCount = 0;
                    }
                    initializeGrid(id, gridData, gridElem);
                });
            }
        }
    }

    function createGridInstanceMethods(gridElem, gridId) {

        Object.defineProperty(
            gridElem[0].grid,
            &#039;export&#039;,
            {
                value: function _export() {
                    exportDataAsExcelFile(gridElem.find(&#039;.grid-content-div&#039;).find(&#039;table&#039;).html());
                }
            }
        );

        Object.defineProperty(
            gridElem[0].grid,
            &#039;activeCellData&#039;,
            {
                get: function _getActiveCellData() {
                    var cell = gridElem.find(&#039;.active-cell&#039;);
                    if (!cell.length)
                        return null;
                    var field = cell.parents(&#039;td&#039;).data(&#039;field&#039;);
                    var colIndex = cell.parents(&#039;.grid-wrapper&#039;).find(&#039;.grid-header-wrapper&#039;).find(&#039;.grid-headerRow&#039;).children(&#039;[data-field=&quot;&#039; + field + &#039;&quot;]&#039;).data(&#039;index&#039;);
                    if (cell[0].type === &#039;checkbox&#039;)
                        return { data: cell[0].checked, row: cell.parents(&#039;tr&#039;).index(), column: colIndex, field: field };
                    return { data: cell.val(), row: cell.parents(&#039;tr&#039;).index(), column: colIndex, field: field, cell: cell.parents(&#039;td&#039;)[0] };
                },
                configurable: false
            });

        Object.defineProperty(
            gridElem[0].grid,
            &#039;selected&#039;,
            {
                get: function _getSelectedItems() {
                    var selectedItems = [];
                    gridElem.find(&#039;.selected&#039;).each(function iteratedSelectedGridItems(idx, val) {
                        selectedItems.push(val);
                    });
                    return selectedItems;
                },
                set: function _setSelectedItems(itemArray) {
                    if (!itemArray || itemArray.constructor !== Array) return;
                    for (var i = 0; i &lt; itemArray.length; i++) {
                        if (typeof itemArray[i].rowIndex !== &#039;number&#039;) continue;
                        var row = gridElem.find(&#039;.grid-content-div&#039;).find(&#039;tbody&#039;).children(&#039;tr:nth-child(&#039; + (itemArray[i].rowIndex + 1) + &#039;)&#039;);
                        if (typeof itemArray[i].columnIndex === &#039;number&#039;) {
                            row.children(&#039;td:nth-child(&#039; + (itemArray[i].columnIndex + 1) + &#039;)&#039;).addClass(&#039;selected&#039;);
                        }
                        else
                            row.addClass(&#039;selected&#039;);
                    }
                },
                configurable: false
            }
        );

        Object.defineProperty(
            gridElem[0].grid,
            &#039;selectedData&#039;,
            {
                get: function _getSelectedGridItemData() {
                    var data = [];
                    gridElem.find(&#039;.selected&#039;).each(function getSelectedElementData(index, value) {
                        var item = $(value);
                        if (value.tagName.toLowerCase() === &#039;tr&#039;) {
                            var rowIndex = item.index();
                            $(value).children().each(function iterateTableCells(idx, val) {
                                var cell = $(val);
                                data.push({ rowIndex: rowIndex, columnIndex: cell.index(), data: cell.text(), field: cell.data(&#039;field&#039;) });
                            });
                        }
                        else {
                            data.push({ rowIndex: item.parents(&#039;tr&#039;).index(), columnIndex: item.index(), data: item.text(), field: item.data(&#039;field&#039;) });
                        }
                    });
                    return data;
                },
                configurable: false
            }
        );



        Object.defineProperties(
            gridElem[0].grid, {
                &#039;bindEvents&#039;: {
                    value: function _bindGridEvents(evt, funcs) {
                        if (!funcs || (typeof funcs !== &#039;function&#039; &amp;&amp; funcs.constructor !== Array)) return false;
                        if (typeof funcs === &#039;function&#039;) funcs = [funcs];
                        if (~events.indexOf(evt)) {
                            storage.grids[gridId].events[evt] = storage.grids[gridId].events[evt].concat(funcs);
                            return true;
                        }
                        return false;
                    },
                    writable: false,
                    configurable: false
                },
                &#039;unbindEvents&#039;: {
                    value: function _unbindEvents(evt, funcs) {
                        if (~events.indexOf(evt) &amp;&amp; (funcs || (typeof funcs === &#039;function&#039; || funcs.constructor === Array))) {
                            if (typeof funcs === &#039;function&#039;) funcs = [funcs];
                            var tmpEvts = [];
                            for (var i = 0; i &lt; storage.grids[gridId].events[evt].length; i++) {
                                for (var j = 0; j &lt; funcs.length; j++) {
                                    if (storage.grids[gridId].events[evt][i] !== funcs[j])
                                        tmpEvts.push(storage.grids[gridId].events[evt][i]);
                                }
                            }
                            storage.grids[gridId].events[evt] = tmpEvts;
                            return true;
                        }
                        return false;
                    },
                    writable: false,
                    configurable: false
                },
                &#039;removeAllEventHandlers&#039;: {
                    value: function _removeAllEventHandlers() {
                        for (var i = 0; i &lt; events.length; i++) {
                            storage.grids[gridId].events[events[i]] = [];
                        }
                    },
                    writable: false,
                    configurable: false
                },
                &#039;getHandledEvents&#039;: {
                    value: function _getHandledEvents() {
                        var evts = [];
                        for (var i = 0; i &lt; events.length; i++) {
                            if (storage.grids[gridId].events[events[i]].length)
                                evts.push(events[i]);
                        }
                        return evts;
                    },
                    writable: false,
                    configurable: false
                },
                &#039;getAvailableEvents&#039;: {
                    value: function _getAvailableEvents() {
                        return events;
                    },
                    writable: false,
                    configurable: false
                },
                &#039;getAggregates&#039;: {
                    value: function _getAggregates() {
                        return storage.grids[gridId].summaryRow;
                    },
                    writable: false,
                    configurable: false
                },
                &#039;getCurrentPageData&#039;: {
                    value: function _getCurrentPageData(index) {
                        var rows = [],
                            result = [],
                            tmpRowModel,
                            validRow;
                        if (typeof index === &#039;number&#039; &amp;&amp; index &gt; -1 &amp;&amp; index &lt;= storage.grids[gridId].dataSource.data.length) {
                            validRow = findValidRows(index);
                            if (validRow) rows.push(validRow);
                        }
                        else {
                            for (var i = 0; i &lt; storage.grids[gridId].pageSize; i++) {
                                validRow = findValidRows(i);
                                if (validRow) rows.push(validRow);
                            }
                        }

                        for (var j = 0; j &lt; rows.length; j++) {
                            tmpRowModel = {};
                            var cells = rows[j].find(&#039;td&#039;);
                            for (var k = 0; k &lt; cells.length; k++) {
                                tmpRowModel[$(cells[k]).data(&#039;field&#039;)] = $(cells[k]).text();
                            }
                            result.push(tmpRowModel);
                        }
                        return result;

                        function findValidRows(index) {
                            var counter = 0;
                            var row = null;
                            storage.grids[gridId].grid.find(&#039;.grid-content-div&#039;).find(&#039;table&#039;).find(&#039;tr&#039;).each(function iterateTableRowsCallback() {
                                if ($(this).hasClass(&#039;grouped_row_header&#039;))
                                    return true;
                                if (counter === index) {
                                    row = $(this);
                                    return false;
                                }
                                counter++;
                            });
                            return row;
                        }
                    },
                    writable: false,
                    configurable: false
                },
                &#039;getCurrentDataSourceData&#039;: {
                    value: function _getCurrentDataSourceData(index) {
                        var i;
                        if (typeof index === &#039;number&#039; &amp;&amp; index &gt; -1 &amp;&amp; index &lt;= storage.grids[gridId].dataSource.data.length) {
                            var val = cloneGridData([].concat(storage.grids[gridId].dataSource.data[index]));
                            delete val[0]._initialRowIndex;
                            return val;
                        }
                        else {
                            var gd = cloneGridData(storage.grids[gridId].dataSource.data);
                            for (i = 0; i &lt; gd.length; i++) {
                                delete gd[i]._initialRowIndex;
                            }
                            return gd;
                        }
                    },
                    writable: false,
                    configurable: false
                },
                &#039;updatePageData&#039;: {
                    value: function _updatePageData(data) {
                        if (data != null &amp;&amp; typeof data === &#039;object&#039; &amp;&amp; data.constructor === Array) {
                            storage.grids[gridId].dataSource.data = data;
                            storage.grids[gridId].pageSize = data.length;
                            storage.grids[gridId].dataSource.rowCount = data.length;
                            storage.grids[gridId].grid.find(&#039;.grid-content-div&#039;).empty();
                            createGridContent(storage.grids[gridId], storage.grids[gridId].grid);
                            storage.grids[gridId].grid.find(&#039;.grid-footer-div&#039;).empty();
                            createGridFooter(storage.grids[gridId], storage.grids[gridId].grid);
                            buildHeaderAggregations(storage.grids[gridId], gridId);
                        }
                    },
                    writable: false,
                    configurable: false
                },
                &#039;updateRowData&#039;: {
                    value: function _updateRowData(rowData) {
                        var appliedUpdate = false;
                        if (!rowData)
                            return;
                        if (rowData.constructor === Array) {
                            for (var i = 0; i &lt; rowData.length; i++) {
                                if (typeof rowData[i].index !== &#039;number&#039; || rowData[i].index &gt;= storage.grids[gridId].dataSource.data.length)
                                    continue;
                                storage.grids[gridId].dataSource.data[rowData[i].index] = rowData[i].data;
                                appliedUpdate = true;
                            }
                        }
                        else if (typeof rowData.index === &#039;number&#039;) {
                            storage.grids[gridId].dataSource.data[rowData.index] = rowData.data;
                            appliedUpdate = true;
                        }

                        if (appliedUpdate) {
                            storage.grids[gridId].grid.find(&#039;.grid-content-div&#039;).empty();
                            createGridContent(storage.grids[gridId], storage.grids[gridId].grid);
                            storage.grids[gridId].grid.find(&#039;.grid-footer-div&#039;).empty();
                            createGridFooter(storage.grids[gridId], storage.grids[gridId].grid);
                            buildHeaderAggregations(storage.grids[gridId], gridId);
                        }
                    },
                    writable: false,
                    configurable: false
                },
                &#039;updateCellData&#039;: {
                    value: function _updateCellData(cellData, setAsDirty) {
                        if (!cellData) return;
                        if (cellData.constructor === Array) {
                            cellData.forEach(function cellIterationCallback(cell) {
                                applyUpdate(cell, setAsDirty);
                            });
                        }
                        else applyUpdate(cellData, setAsDirty);

                        function applyUpdate(cell, setAsDirty) {
                            if (typeof cell.index !== &#039;number&#039; || typeof cell.field !== &#039;string&#039; || cell.index &gt; storage.grids[gridId].dataSource.data.length)
                                return;
                            if (storage.grids[gridId].columns[cell.field]) {
                                var dataType = storage.grids[gridId].columns[cell.field].type;
                                if (!dataType)
                                    dataType = &#039;string&#039;;
                                if (dataType !== &#039;time&#039; &amp;&amp; dataType !== &#039;date&#039; &amp;&amp; dataType !== &#039;datetime&#039;) {
                                    if (typeof cell.value !== dataType)
                                        return;
                                }
                                else {
                                    var re = new RegExp(dataTypes[dataType]);
                                    if (!re.test(cell.value)) return;
                                }
                                storage.grids[gridId].dataSource.data[cell.index][cell.field] = cell.value;
                                var tableCell;
                                if (storage.grids[gridId].groupedBy) {
                                    var counter = 0;
                                    storage.grids[gridId].grid.find(&#039;.grid-content-div&#039;).find(&#039;table&#039;).find(&#039;tr&#039;).each(function iterateTableRowsCallback() {
                                        if ($(this).hasClass(&#039;grouped_row_header&#039;))
                                            return true;
                                        if (counter === cell.index) {
                                            tableCell = $(this).find(&#039;[data-field=&quot;&#039; + cell.field + &#039;&quot;]&#039;);
                                            return false;
                                        }
                                        counter++;
                                    });
                                }
                                else
                                    tableCell = storage.grids[gridId].grid.find(&#039;.grid-content-div&#039;).find(&#039;table&#039;).find(&#039;tr:nth-child(&#039; + (cell.index + 1) + &#039;)&#039;).find(&#039;[data-field=&quot;&#039; + cell.field + &#039;&quot;]&#039;);
                                var text = getFormattedCellText(gridId, cell.field, cell.value) || cell.value;
                                tableCell.text(text);
                                if (setAsDirty) tableCell.prepend(&#039;&lt;span class=&quot;dirty&quot;&gt;&lt;/span&gt;&#039;);
                            }
                        }
                    },
                    writable: false,
                    configurable: false
                },
                &#039;destroy&#039;: {
                    value: function _destroy() {
                        findChildren(storage.grids[gridId].grid.children());
                        delete storage.grids[gridId];

                        function findChildren(nodes) {
                            for (var i = 0; i &lt; nodes.length; i++) {
                                var child = $(nodes[i]);
                                while (child.children().length)
                                    findChildren(child.children());
                                child.off();
                                child.remove();
                            }
                        }
                    },
                    writable: false,
                    configurable: false
                },
                &#039;removeSelection&#039;: {
                    value: function _removeSelection() {
                        gridElem.find(&#039;.selected&#039;).each(function removeSelectedClass(idx, val) {
                            $(val).removeClass(&#039;selected&#039;);
                        });
                    },
                    writable: false,
                    configurable: false
                }
            });

        var keys = Object.getOwnPropertyNames(gridElem[0].grid);
        for (var i = 0; i &lt; keys.length; i++) {
            Object.preventExtensions(gridElem[0].grid[keys[i]]);
        }
    }

    function getInitialGridData(dataSource, callback) {
        if (dataSource &amp;&amp; typeof dataSource.data === &#039;object&#039;)
            callback(null, { data: dataSource.data, rowCount: dataSource.rowCount });
        else if (typeof dataSource.get == &#039;function&#039;) {
            dataSource.get({ pageSize: 25, pageNum: 1 },
                function gridDataCallback(data) {
                if (data) callback(null, data);
                else callback(true, {});
            });
        }
        else callback(true, {});
    }

    function initializeGrid(id, gridData, gridElem) {
        var storageData = cloneGridData(gridData);
        storageData.events = {
            beforeCellEdit: typeof storageData.beforeCellEdit === &#039;object&#039; &amp;&amp; storageData.beforeCellEdit.constructor === Array ? storageData.beforeCellEdit : [],
            cellEditChange: typeof storageData.cellEditChange === &#039;object&#039; &amp;&amp; storageData.cellEditChange.constructor === Array ? storageData.cellEditChange : [],
            afterCellEdit: typeof storageData.afterCellEdit === &#039;object&#039; &amp;&amp; storageData.afterCellEdit.constructor === Array ? storageData.afterCellEdit : [],
            pageRequested: typeof storageData.pageRequested === &#039;object&#039; &amp;&amp; storageData.pageRequested.constructor === Array ? storageData.pageRequested : [],
            beforeDataBind: typeof storageData.beforeDataBind === &#039;object&#039; &amp;&amp; storageData.beforeDataBind.constructor === Array ? storageData.beforeDataBind : [],
            afterDataBind: typeof storageData.afterDataBind === &#039;object&#039; &amp;&amp; storageData.afterDataBind.constructor === Array ? storageData.afterDataBind : [],
            columnReorder: typeof storageData.columnReorder === &#039;object&#039; &amp;&amp; storageData.columnReorder.constructor === Array ? storageData.columnReorder : []
        };

        for (var event in storageData.events) {
            if (storageData.events[event].length) {
                storageData.events[event] = storageData.events[event].map(function mapEventsCallback(fn) {
                    if (typeof fn == &#039;function&#039;) return fn;
                });
            }
        }

        delete storageData.beforeCellEdit;
        delete storageData.cellEditChange;
        delete storageData.afterCellEdit;
        delete storageData.pageRequested;
        delete storageData.beforeDataBind;
        delete storageData.afterDataBind;
        delete storageData.columnReorder;

        storageData.originalData = cloneGridData(gridData.dataSource.data);
        storageData.pageNum = 1;
        storageData.pageSize = gridData.pageSize || 25;
        storageData.grid = gridElem;
        storageData.currentEdit = {};
        storageData.pageRequest = {};
        storageData.putRequest = {};
        storageData.resizing = false;
        storageData.sortedOn = [];
        if (!storageData.dataSource.rowCount) storageData.dataSource.rowCount = gridData.dataSource.data.length;

        var eventObj = { element: storageData.grid };
        callGridEventHandlers(storageData.events.beforeDataBind, storageData.grid, eventObj);

        storage.grids[id] = storageData;

        if (gridData.summaryRow &amp;&amp; gridData.summaryRow.positionAt === &#039;top&#039;) buildHeaderAggregations(gridData, id);

        createGridFooter(gridData, gridElem);
        createGridContent(gridData, gridElem);

        callGridEventHandlers(storageData.events.afterDataBind, storageData.grid, eventObj);
    }

    function addNewColumns(newData, gridElem) {
        var oldGrid = $(gridElem).find(&#039;.grid-wrapper&#039;);
        var id = oldGrid.data(&#039;grid_id&#039;);
        var oldData = storage.grids[id].data;

        for (var i = 0; i &lt; newData.length; i++) {
            for (var col in newData[i]) {
                if (!oldData.data[i][col]) {
                    oldData.data[i][col] = newData[i][col];
                }
                if (!oldData.columns[col]) {
                    oldData.columns[col] = { field: col, title: col, index: Object.keys(oldData.columns).length };
                }
            }
        }

        gridElem.removeChild(oldGrid);
        create(oldData, gridElem);
    }

    function createGridHeaders(gridData, gridElem) {
        var gridHeader = gridElem.find(&#039;.grid-header-div&#039;);
        var gridHeadWrap = gridHeader.find(&#039;.grid-header-wrapper&#039;);
        var headerTable = $(&#039;&lt;table&gt;&lt;/table&gt;&#039;).appendTo(gridHeadWrap);
        headerTable.css(&#039;width&#039;,&#039;auto&#039;);
        var colgroup = $(&#039;&lt;colgroup&gt;&lt;/colgroup&gt;&#039;).appendTo(headerTable);
        var headerTHead = $(&#039;&lt;thead&gt;&lt;/thead&gt;&#039;).appendTo(headerTable);
        var headerRow = $(&#039;&lt;tr class=grid-headerRow&gt;&lt;/tr&gt;&#039;).appendTo(headerTHead);
        var index = 0;

        if (gridData.groupedBy &amp;&amp; gridData.groupedBy !== &#039;none&#039;) {
            colgroup.append(&#039;&lt;col class=&quot;group_col&quot;/&gt;&#039;);
            headerRow.append(&#039;&lt;th class=&quot;grid-header-cell grouped_cell&quot;&gt;&lt;/th&gt;&#039;);
        }

        for (var col in gridData.columns) {
            if (typeof gridData.columns[col] !== &#039;object&#039;)
                continue;
            $(&#039;&lt;col/&gt;&#039;).appendTo(colgroup);
            var text = gridData.columns[col].title || col;
            var th = $(&#039;&lt;th id=&quot;&#039; + col + &#039;_grid_id_&#039; + gridHeader.data(&#039;grid_header_id&#039;) + &#039;&quot; data-field=&quot;&#039; + col + &#039;&quot; data-index=&quot;&#039; + index + &#039;&quot; class=grid-header-cell&gt;&lt;/th&gt;&#039;).appendTo(headerRow);

            if (typeof gridData.columns[col].attributes === &#039;object&#039; &amp;&amp; gridData.columns[col].attributes.headerClasses &amp;&amp; gridData.columns[col].attributes.headerClasses.constructor ===  Array) {
                for (var i = 0; i &lt; gridData.columns[col].attributes.headerClasses.length; i++) {
                    th.addClass(gridData.columns[col].attributes.headerClasses[i]);
                }
            }

            if (gridData.reorderable === true &amp;&amp; (typeof gridData.columns[col].reorderable === &#039;undefined&#039; || gridData.columns[col].reorderable === true)) {
                th.prop(&#039;draggable&#039;, true);
                setDragAndDropListeners(th);
            }
            if (gridData.sortable === true &amp;&amp; (typeof gridData.columns[col].sortable === &#039;undefined&#039; || gridData.columns[col].sortable === true)) {
                setSortableClickListener(th);
            }
            if (gridData.columns[col].filterable === true) {
                setFilterableClickListener(th, gridData, col);
                createCellEditSaveDiv(gridData, gridElem);
            }

            if (gridData.columns[col].editable || gridData.columns[col].selectable || gridData.groupable)
                createCellEditSaveDiv(gridData, gridElem);

            $(&#039;&lt;a class=&quot;header-anchor&quot; href=&quot;#&quot;&gt;&lt;/a&gt;&#039;).appendTo(th).text(text);

            index++;
        }
        headerTable.css(&#039;width&#039;,&#039;&#039;);
        setColWidth(gridData, gridElem);
    }

    function buildHeaderAggregations(gridData, gridId) {
        var sum = buildAggregatesRow(gridData, gridId);
        if (sum) {
            var headerTHead = $(&#039;#grid-header-&#039; + gridId).find(&#039;thead&#039;);
            var sumRow = headerTHead.find(&#039;.summary-row-header&#039;);
            if (sumRow.length)
                sumRow.remove();
            sumRow = $(&#039;&lt;tr class=summary-row-header&gt;&lt;/tr&gt;&#039;).appendTo(headerTHead);
            if (gridData.groupedBy &amp;&amp; gridData.groupedBy !== &#039;none&#039;) {
                sumRow.append(&#039;&lt;th class=&quot;grid-header-cell grouped_cell&quot;&gt;&lt;/th&gt;&#039;);
            }
            for (var col in sum) {
                var text = sum[col] != null ? sum[col] : &#039;&#039;;
                sumRow.append(&#039;&lt;td data-field=&quot;&#039; + col + &#039;&quot; class=summary-cell-header&gt;&#039; + text + &#039;&lt;/td&gt;&#039;);
            }
        }
    }

    function buildAggregatesRow(gridData, gridId) {
        var aggData = {},
            data = gridData.alteredData ? gridData.alteredData :  gridData.dataSource.data,
            total, i;
        for (var col in gridData.columns) {
            var type = typeof gridData.columns[col].type === &#039;string&#039; ? gridData.columns[col].type : &#039;&#039;;
            var text;
            if (!gridData.summaryRow[col]) {
                aggData[col] = &#039;&#039;;
                continue;
            }
            if (typeof gridData.dataSource.get === &#039;function&#039;) {
                if (gridData.summaryRow[col].type &amp;&amp; gridData.summaryRow[col].value) {
                    text = getFormattedCellText(gridId, col, gridData.summaryRow[col].value) || gridData.summaryRow[col].value;
                    aggData[col] = aggregates[gridData.summaryRow[col].type] + text;
                }
                else
                    aggData[col] = null;
            }
            else {
                switch (gridData.summaryRow[col].type) {
                    case &#039;count&#039;:
                        text = getFormattedCellText(gridId, col, gridData.dataSource.rowCount) || gridData.dataSource.rowCount;
                        aggData[col] = aggregates[gridData.summaryRow[col].type] + text;
                        break;
                    case &#039;average&#039;:
                        total = 0;
                        for (i = 0; i &lt; gridData.dataSource.rowCount; i++) {
                            total += parseFloat(data[i][col]);
                        }
                        var avg = parseFloat(total/parseFloat(gridData.dataSource.rowCount)).toFixed(2);
                        text = getFormattedCellText(gridId, col, avg) || avg;
                        aggData[col] = aggregates[gridData.summaryRow[col].type] + text;
                        break;
                    case &#039;total&#039;:
                        total = 0;
                        for (i = 0; i &lt; gridData.dataSource.rowCount; i++) {
                            total += parseFloat(data[i][col]);
                        }
                        if (type === &#039;currency&#039;) total = total.toFixed(2);
                        text = getFormattedCellText(gridId, col, total) || total;
                        aggData[col] = aggregates[gridData.summaryRow[col].type] + text;
                        break;
                    case &#039;min&#039;:
                        var min;
                        for (i = 0; i &lt; gridData.dataSource.rowCount; i++) {
                            if (!min || parseFloat(data[i][col]) &lt; min) min = parseFloat(data[i][col]);
                        }
                        text = getFormattedCellText(gridId, col, min) || min;
                        aggData[col] = aggregates[gridData.summaryRow[col].type] + text;
                        break;
                    case &#039;max&#039;:
                        var max;
                        for (i = 0; i &lt; gridData.dataSource.rowCount; i++) {
                            if (!max || parseFloat(data[i][col]) &gt; max) max = parseFloat(data[i][col]);
                        }
                        text = getFormattedCellText(gridId, col, max) || max;
                        aggData[col] = aggregates[gridData.summaryRow[col].type] + text;
                        break;
                    case &#039;&#039;:
                        aggData[col] = null;
                        break;
                }
            }
        }
        for (col in gridData.columns) {
            if (aggData[col] != null)
                return aggData;
        }
        return null;
    }

    function createGridContent(gridData, gridElem) {
        var contentHeight;
        var footerHeight = parseFloat(gridElem.find(&#039;.grid-footer-div&#039;).css(&#039;height&#039;));
        var headerHeight = parseFloat(gridElem.find(&#039;.grid-header-div&#039;).css(&#039;height&#039;));
        var toolbarHeight = 0;
        if (gridElem.find(&#039;.toolbar&#039;))
            toolbarHeight = parseFloat(gridElem.find(&#039;.toolbar&#039;).css(&#039;height&#039;));

        contentHeight = gridData.height &amp;&amp; isNumber(parseFloat(gridData.height)) ? gridData.height - (headerHeight + footerHeight + toolbarHeight) + &#039;px&#039; : &#039;250px&#039;;
        var gridContent = gridElem.find(&#039;.grid-content-div&#039;).css(&#039;height&#039;, contentHeight);
        var id = gridContent.data(&#039;grid_content_id&#039;);
        var gcOffsets = gridContent.offset();
        var top = gcOffsets.top + (gridContent.height()/2) + $(window).scrollTop();
        var left = gcOffsets.left + (gridContent.width()/2) + $(window).scrollLeft();
        var loader = $(&#039;&lt;span id=&quot;loader-span&quot; class=&quot;spinner&quot;&gt;&lt;/span&gt;&#039;).appendTo(gridContent).css(&#039;top&#039;, top).css(&#039;left&#039;, left);
        var contentTable = $(&#039;&lt;table id=&quot;&#039; + gridElem[0].id + &#039;_content&quot; style=&quot;height:auto;&quot;&gt;&lt;/table&gt;&#039;).appendTo(gridContent);
        var colGroup = $(&#039;&lt;colgroup&gt;&lt;/colgroup&gt;&#039;).appendTo(contentTable);
        var contentTBody = $(&#039;&lt;tbody&gt;&lt;/tbody&gt;&#039;).appendTo(contentTable);
        if (gridData.selectable) attachTableSelectHandler(contentTBody);
        var columns = [];
        gridElem.find(&#039;th&#039;).each(function headerIterationCallback(idx, val) {
            if (!$(val).hasClass(&#039;group_spacer&#039;))
                columns.push($(val).data(&#039;field&#039;));
        });

        var rowStart = 0;
        var rowEnd = gridData.dataSource.data.length;
        var curRow;
        var rows = gridData.rows;

        for (var i = (rowStart); i &lt; rowEnd; i++) {
            gridData.dataSource.data[i]._initialRowIndex = i;
            if (gridData.groupedBy &amp;&amp; gridData.groupedBy !== &#039;none&#039;) {
                if (!curRow || gridData.dataSource.data[i][gridData.groupedBy] !== curRow) {
                    curRow = gridData.dataSource.data[i][gridData.groupedBy];
                    var groupedText = getFormattedCellText(id, gridData.groupedBy, curRow) || curRow;
                    var groupTr = $(&#039;&lt;tr class=&quot;grouped_row_header&quot;&gt;&lt;/tr&gt;&#039;).appendTo(contentTBody);
                    var groupTitle = gridData.columns[gridData.groupedBy].title || gridData.groupedBy;
                    groupTr.append(&#039;&lt;td colspan=&quot;&#039; + (columns.length + 1) + &#039;&quot;&gt;&lt;p class=&quot;grouped&quot;&gt;&lt;a class=&quot;group-desc sortSpan group_acc_link&quot;&gt;&lt;/a&gt;&#039; + groupTitle + &#039;: &#039; + groupedText + &#039;&lt;/p&gt;&lt;/td&gt;&#039;);
                }
            }
            else if (!gridData.groupedBy &amp;&amp; gridElem.find(&#039;.group_spacer&#039;).length) {
                $(document).find(&#039;.group_col&#039;).remove();
                $(document).find(&#039;.group_spacer&#039;).remove();
            }
            var tr = $(&#039;&lt;tr&gt;&lt;/tr&gt;&#039;).appendTo(contentTBody);
            if (i % 2) {
                tr.addClass(&#039;alt-row&#039;);
                if (rows &amp;&amp; rows.alternateRows &amp;&amp; rows.alternateRows.constructor === Array)
                    for (var x = 0; x &lt; rows.alternateRows.length; x++) {
                        tr.addClass(rows.alternateRows[x]);
                    }
            }

            if (rows &amp;&amp; rows.all &amp;&amp; rows.all.constructor === Array) {
                for (var y = 0; y &lt; rows.all.length; y++) {
                    tr.addClass(rows.all[y]);
                }
            }

            if (gridData.groupedBy &amp;&amp; gridData.groupedBy !== &#039;none&#039;)
                tr.append(&#039;&lt;td class=&quot;grouped_cell&quot;&gt;&amp;nbsp&lt;/td&gt;&#039;);

            for (var j = 0; j &lt; columns.length; j++) {
                var td = $(&#039;&lt;td data-field=&quot;&#039; + columns[j] + &#039;&quot; class=&quot;grid-content-cell&quot;&gt;&lt;/td&gt;&#039;).appendTo(tr);
                if (gridData.columns[columns[j]].attributes &amp;&amp; gridData.columns[columns[j]].attributes.cellClasses &amp;&amp; gridData.columns[columns[j]].attributes.cellClasses.constructor === Array) {
                    for (var z = 0; z &lt; gridData.columns[columns[j]].attributes.cellClasses.length; z++) {
                        td.addClass(gridData.columns[columns[j]].attributes.cellClasses[z]);
                    }
                }
                var text = getFormattedCellText(id, columns[j], gridData.dataSource.data[i][columns[j]]) || gridData.dataSource.data[i][columns[j]];
                td.text(text);
                if (gridData.columns[columns[j]].editable) makeCellEditable(id, td);
                else if (gridData.columns[columns[j]].selectable) makeCellSelectable(id, td);
            }
        }

        for (var k = 0; k &lt; columns.length; k++) {
            colGroup.append(&#039;&lt;col/&gt;&#039;);
        }
        if (gridData.groupedBy &amp;&amp; gridData.groupedBy !== &#039;none&#039;)
            colGroup.prepend(&#039;&lt;col class=&quot;group_col&quot;/&gt;&#039;);

        if (gridData.summaryRow &amp;&amp; gridData.summaryRow.positionAt === &#039;bottom&#039;) {
            var sum = buildAggregatesRow(gridData, id);
            var sumRow = $(&#039;&lt;tr class=&quot;summary-row-footer&quot;&gt;&lt;/tr&gt;&#039;).appendTo(contentTBody);
            for (var col in sum) {
                sumRow.append(&#039;&lt;td data-field=&quot;&#039; + col + &#039;&quot; class=&quot;summary-cell-footer&quot;&gt;&#039; + sum[col] + &#039;&lt;/td&gt;&#039;);
            }
        }

        createGroupTrEventHandlers();

        gridContent.on(&#039;scroll&#039;, function contentDivScrollCallback(e) {
            var cDiv = $(e.currentTarget);
            var headWrap = cDiv.parents(&#039;.grid-wrapper&#039;).find(&#039;.grid-header-wrapper&#039;);
            if (storage.grids[headWrap.parent().data(&#039;grid_header_id&#039;)].resizing)
                return;
            headWrap.scrollLeft(cDiv.scrollLeft());
        });

        var headerId = &#039;grid-header-&#039; + gridContent.data(&#039;grid_content_id&#039;);
        var headDiv = $(&#039;#&#039; + headerId);
        var sizeDiff = headDiv[0].clientWidth - gridContent[0].clientWidth;
        headDiv.css(&#039;paddingRight&#039;, sizeDiff);

        copyGridWidth(gridElem);

        storage.grids[id].dataSource.data = gridData.dataSource.data;
        loader.remove();
        storage.grids[id].updating = false;
    }

    function attachTableSelectHandler(tableBody) {
        var gridId = tableBody.parents(&#039;.grid-wrapper&#039;).data(&#039;grid_id&#039;);
        var isSelectable = storage.grids[gridId].selectable;
        if (isSelectable) {
            $(document).on(&#039;click&#039;, function tableBodySelectCallback(e) {
                if (e.target === tableBody[0] || $(e.target).parents(&#039;tbody&#039;)[0] === tableBody[0]) {
                    if (storage.grids[gridId].selecting) {
                        storage.grids[gridId].selecting = false;
                        return;
                    }
                    $(&#039;.selected&#039;).each(function iterateSelectedItemsCallback(idx, elem) {
                        $(elem).removeClass(&#039;selected&#039;);
                    });
                    var target = $(e.target);
                    if (isSelectable === &#039;cell&#039; &amp;&amp; target[0].tagName.toUpperCase() === &#039;TD&#039;)
                        target.addClass(&#039;selected&#039;);
                    else if (target[0].tagName.toUpperCase() === &#039;TR&#039;)
                        target.addClass(&#039;selected&#039;);
                    else
                        target.parents(&#039;tr&#039;).first().addClass(&#039;selected&#039;);
                }
            });
        }
        if (isSelectable === &#039;multi-row&#039; || isSelectable === &#039;multi-cell&#039;) {
            $(document).on(&#039;mousedown&#039;, function mouseDownDragCallback(event) {
                if (event.target === tableBody[0] || $(event.target).parents(&#039;tbody&#039;)[0] === tableBody[0]) {
                    storage.grids[gridId].selecting = true;
                    var contentDiv = tableBody.parents(&#039;.grid-content-div&#039;),
                        overlay = $(&#039;&lt;div class=&quot;selection-highlighter&quot;&gt;&lt;/div&gt;&#039;).appendTo(storage.grids[gridId].grid);
                    overlay.css(&#039;top&#039;, event.pageY).css(&#039;left&#039;, event.pageX).css(&#039;width&#039;, 0).css(&#039;height&#039;, 0);
                    overlay.data(&#039;origin-y&#039;, event.pageY + contentDiv.scrollTop()).data(&#039;origin-x&#039;, event.pageX + contentDiv.scrollLeft()).data(&#039;mouse-pos-x&#039;, event.pageX).data(&#039;mouse-pos-y&#039;, event.pageY);
                    overlay.data(&#039;previous-top&#039;, event.pageY).data(&#039;previous-left&#039;, event.pageX);
                    overlay.data(&#039;previous-bottom&#039;, event.pageY).data(&#039;previous-right&#039;, event.pageX);
                    overlay.data(&#039;origin-scroll_top&#039;, contentDiv.scrollTop()).data(&#039;origin-scroll_left&#039;, contentDiv.scrollLeft());
                    overlay.data(&#039;last-scroll_top_pos&#039;, contentDiv.scrollTop()).data(&#039;last-scroll_left_pos&#039;, contentDiv.scrollLeft());
                    overlay.data(&#039;actual-height&#039;, 0).data(&#039;actual-width&#039;, 0).data(&#039;event-type&#039;, &#039;mouse&#039;);

                    $(document).one(&#039;mouseup&#039;, function mouseUpDragCallback() {
                        $(&#039;.selected&#039;).each(function iterateSelectedItemsCallback(idx, elem) {
                            $(elem).removeClass(&#039;selected&#039;);
                        });
                        var overlay = $(&quot;.selection-highlighter&quot;);
                        selectHighlighted(overlay, gridId);
                        overlay.remove();
                        contentDiv.off(&#039;scroll&#039;);
                        $(document).off(&#039;mousemove&#039;);
                    });

                    contentDiv.on(&#039;scroll&#039;, function updateSelectOverlayOnScrollHandler() {
                        if (storage.grids[gridId].selecting) {
                            overlay.data(&#039;event-type&#039;, &#039;scroll&#039;);
                            setOverlayDimensions(contentDiv, overlay);
                        }
                    });

                    $(document).on(&#039;mousemove&#039;, function updateSelectOverlayOnMouseMoveHandler(ev) {
                        if (storage.grids[gridId].selecting) {
                            var domTag = ev.target.tagName.toUpperCase();
                            if (domTag === &#039;INPUT&#039; || domTag === &#039;SELECT&#039;) return;

                            overlay.data(&#039;event-type&#039;, &#039;mouse&#039;);
                            overlay.data(&#039;mouse-pos-x&#039;, ev.pageX).data(&#039;mouse-pos-y&#039;, ev.pageY);
                            setOverlayDimensions(storage.grids[gridId].grid.find(&#039;.grid-content-div&#039;), overlay);
                        }
                    });
                }
            });
        }

        function setOverlayDimensions(contentDiv, overlay) {
            window.getSelection().removeAllRanges();

            var contentOffset = contentDiv.offset(),
                ctHeight = contentDiv[0].clientHeight,
                ctWidth = contentDiv[0].clientWidth,
                ctTop = contentOffset.top,
                ctLeft = contentOffset.left,
                ctBottom = ctTop + ctHeight,
                ctRight = ctLeft + ctWidth,
                ctScrollTop = contentDiv.scrollTop(),
                ctScrollLeft = contentDiv.scrollLeft(),
                top = Math.min(overlay.data(&#039;mouse-pos-y&#039;), ctTop, overlay.data(&#039;previous-top&#039;)),
                left = Math.min(overlay.data(&#039;mouse-pos-x&#039;), ctLeft, overlay.data(&#039;previous-left&#039;)),
                bottom = Math.max(top, overlay.data(&#039;previous-bottom&#039;)),
                right = Math.max(left, overlay.data(&#039;previous-right&#039;)),
                trueHeight;

            if ((top === overlay.data(&#039;previous-top&#039;) || top &lt; ctTop) &amp;&amp; (bottom === overlay.data(&#039;previous-bottom&#039;) || bottom &gt; ctBottom) &amp;&amp;
                (left === overlay.data(&#039;previous-left&#039;) || left &lt; ctLeft) &amp;&amp; (right === overlay.data(&#039;previous-right&#039;) || right &gt; ctRight) &amp;&amp;
                ctScrollTop === overlay.data(&#039;last-scroll_top_pos&#039;) &amp;&amp; ctScrollLeft === overlay.data(&#039;last-scroll_left_pos&#039;))
                return;

            var dimObj = {};
            dimObj.eventType = overlay.data(&#039;event-type&#039;);
            dimObj.overlay = {};
            dimObj.overlay.smallDim = top;
            dimObj.overlay.largeDim = bottom;
            dimObj.overlay.origin = overlay.data(&#039;origin-y&#039;);
            dimObj.overlay.mousePosition = overlay.data(&#039;mouse-pos-y&#039;);
            dimObj.container = {};
            dimObj.container.smallDim = ctTop;
            dimObj.container.largeDim = ctBottom;
            dimObj.container.scrollPos = ctScrollTop;
            dimObj.container.scrollLength = contentDiv[0].scrollHeight;
            dimObj.container.clientLength = ctHeight;

            var dims = determineOverlayDimensions(dimObj);
            trueHeight = dims.trueSize;
            ctScrollTop = dims.scrollPos;
            contentDiv.scrollTop(dims.scrollPos);
            top = dims.smallDim;
            bottom = dims.largeDim;

            dimObj.overlay.smallDim = left;
            dimObj.overlay.largeDim = right;
            dimObj.overlay.origin = overlay.data(&#039;origin-x&#039;);
            dimObj.overlay.mousePosition = overlay.data(&#039;mouse-pos-x&#039;);
            dimObj.container.smallDim = ctLeft;
            dimObj.container.largeDim = ctRight;
            dimObj.container.scrollPos = ctScrollLeft;
            dimObj.container.scrollLength = contentDiv[0].scrollWidth;
            dimObj.container.clientLength = ctWidth;

            dims = determineOverlayDimensions(dimObj);
            contentDiv.scrollLeft(dims.scrollPos);

            overlay.css(&#039;top&#039;, top).css(&#039;left&#039;, dims.smallDim).css(&#039;height&#039;, (bottom - top)).css(&#039;width&#039;, (dims.largeDim - dims.smallDim));
            overlay.data(&#039;actual-height&#039;, trueHeight).data(&#039;actual-width&#039;, dims.trueSize);
            overlay.data(&#039;previous-top&#039;, top).data(&#039;previous-left&#039;, dims.smallDim).data(&#039;previous-bottom&#039;, bottom).data(&#039;previous-right&#039;, dims.largeDim);
            overlay.data(&#039;last-scroll_top_pos&#039;, ctScrollTop).data(&#039;last-scroll_left_pos&#039;, dims.scrollPos);
        }
    }

    function determineOverlayDimensions(context) {
        var locAdjustment, scrollAdjustment, smallDim, largeDim,
            trueSize,
            scrollPos = context.container.scrollPos;
        if (context.eventType === &#039;scroll&#039;) {
            if (context.overlay.origin &lt; context.container.smallDim + context.container.scrollPos) {
                if (context.overlay.mousePosition - 20 &lt;= context.container.smallDim &amp;&amp; context.container.scrollPos &gt; 0) {
                    locAdjustment = context.overlay.smallDim + 25;
                    scrollAdjustment = context.overlay.mousePosition - locAdjustment;
                    scrollPos = context.container.scrollPos + scrollAdjustment;
                    largeDim = locAdjustment;
                    smallDim = context.overlay.smallDim;
                }
                else {
                    smallDim = context.container.smallDim;
                    largeDim = context.overlay.mousePosition &gt; context.container.largeDim ? context.container.largeDim : context.overlay.mousePosition;
                }
                trueSize = largeDim + scrollPos - context.overlay.origin;
            }
            else if (context.overlay.origin &gt; context.container.largeDim + context.container.scrollPos) {
                if (context.overlay.mousePosition + 20 &gt;= context.container.largeDim &amp;&amp; context.container.scrollPos &lt; context.container.scrollLength - context.container.clientLength) {
                    locAdjustment = context.container.largeDim - 25;
                    scrollAdjustment = locAdjustment - context.overlay.mousePosition;
                    scrollPos = context.container.scrollPos - scrollAdjustment;
                    smallDim = locAdjustment;
                    largeDim = context.overlay.largeDim;
                }
                else {
                    smallDim = context.overlay.mousePosition &lt; context.container.smallDim ? context.container.smallDim : context.overlay.mousePosition;
                    largeDim = context.container.largeDim;
                }
                trueSize = context.overlay.origin - smallDim - scrollPos;
            }
            else {
                if (context.overlay.origin &lt; context.overlay.mousePosition + context.container.scrollPos) {
                    smallDim = context.overlay.origin - context.container.scrollPos;
                    largeDim = context.overlay.mousePosition &gt; context.container.largeDim ? context.container.largeDim : context.overlay.mousePosition;
                }
                else {
                    smallDim = context.overlay.mousePosition &lt; context.container.smallDim ? context.container.smallDim : context.overlay.mousePosition;
                    largeDim = context.overlay.origin - context.container.scrollPos;
                }
                trueSize = largeDim - smallDim;
            }
        }
        else {
            if (context.overlay.origin &gt; (context.container.smallDim + context.container.scrollPos) &amp;&amp; context.overlay.origin &lt; (context.container.largeDim + context.container.scrollPos)) {
                var minVal = Math.min((context.overlay.origin - context.container.scrollPos), context.overlay.mousePosition);
                var maxVal = minVal === (context.overlay.origin - context.container.scrollPos) ? context.overlay.mousePosition : (context.overlay.origin - context.container.scrollPos);
                smallDim = minVal &lt; context.container.smallDim ? context.container.smallDim : minVal;
                largeDim = maxVal &gt; context.container.largeDim ? context.container.largeDim : maxVal;
                trueSize = largeDim - smallDim;
            }
            else if (context.overlay.origin &lt;= context.container.smallDim + context.container.scrollPos) {
                smallDim = context.container.smallDim;
                if (context.overlay.mousePosition - 20 &lt;= context.container.smallDim &amp;&amp; context.container.scrollPos &gt; 0) {
                    locAdjustment = smallDim + 25;
                    scrollAdjustment = context.overlay.mousePosition - locAdjustment;
                    scrollPos = context.container.scrollPos + scrollAdjustment;
                    largeDim = locAdjustment;
                }
                else largeDim = context.overlay.mousePosition &gt; context.container.largeDim ? context.container.largeDim : context.overlay.mousePosition;
                trueSize = largeDim + scrollPos - context.overlay.origin;
            }
            else {
                largeDim = context.container.largeDim;
                if (context.overlay.mousePosition + 20 &gt;= context.container.largeDim &amp;&amp; context.container.scrollPos &lt; context.container.scrollLength - context.container.clientLength) {
                    locAdjustment = largeDim - 25;
                    scrollAdjustment = locAdjustment - context.overlay.mousePosition;
                    scrollPos = context.container.scrollPos - scrollAdjustment;
                    smallDim = locAdjustment;
                }
                else smallDim = context.overlay.mousePosition &lt; context.container.smallDim ? context.container.smallDim : context.overlay.mousePosition;
                trueSize = context.overlay.origin - smallDim - context.container.scrollPos;
            }
        }
        return {
            trueSize: trueSize,
            smallDim: smallDim || context.overlay.smallDim,
            largeDim: largeDim || context.overlay.largeDim,
            scrollPos: scrollPos || context.container.scrollPos
        };
    }

    function selectHighlighted(overlay, gridId) {
        var contentDiv = storage.grids[gridId].grid.find(&#039;.grid-content-div&#039;),
            ctOffset = contentDiv.offset(),
            ctHeight = contentDiv.height,
            ctWidth = contentDiv.width(),
            width = overlay.width(),
            height = overlay.height(),
            offset = overlay.offset(),
            top = offset.top,
            left = offset.left,
            right = parseFloat(overlay.data(&#039;actual-width&#039;)) + left,
            bottom = parseFloat(overlay.data(&#039;actual-height&#039;)) + top;

        if (top + overlay.data(&#039;actual-height&#039;) &gt; ctOffset.top + ctHeight || top + height - overlay.data(&#039;actual-height&#039;) &lt; ctOffset.top) {
            if (overlay.data(&#039;origin-scroll_top&#039;) &gt; overlay.data(&#039;last-scroll_top_pos&#039;)) bottom = top + overlay.data(&#039;actual-height&#039;);
            else {
                bottom = top + height;
                top = bottom - overlay.data(&#039;actual-height&#039;);
            }
        }

        if (left + overlay.data(&#039;actual-width&#039;) &gt; ctOffset.left + ctWidth || left + width - overlay.data(&#039;actual-width&#039;) &lt; ctOffset.left) {
            if (overlay.data(&#039;origin-scroll_left&#039;) &gt; overlay.data(&#039;last-scroll_left_pos&#039;)) right = left + overlay.data(&#039;actual-width&#039;);
            else {
                right = left + width;
                left = right = overlay.data(&#039;actual-width&#039;);
            }
        }

        var gridElems = storage.grids[gridId].selectable === &#039;multi-cell&#039; ? contentDiv.find(&#039;td&#039;) : contentDiv.find(&#039;tr&#039;);

        gridElems.each(function highlightGridElemsCallback(idx, val) {
            var element = $(val),
                eOffset = element.offset(),
                eTop = eOffset.top,
                eLeft = eOffset.left,
                eRight = parseFloat(element.css(&#039;width&#039;)) + eLeft,
                eBottom = parseFloat(element.css(&#039;height&#039;)) + eTop;

            if (left &gt; eRight || right &lt; eLeft || top &gt; eBottom || bottom &lt; eTop) return;
            else element.addClass(&#039;selected&#039;);
        });
    }

    function createGroupTrEventHandlers() {
        $(&#039;.group_acc_link&#039;).each(function iterateAccordionsCallback(idx, val) {
            $(val).data(&#039;state&#039;, &#039;open&#039;);
        }).on(&#039;click&#039;, function groupedAccordionsClickListenerCallback(e) {
            var accRow = $(e.currentTarget).parents(&#039;tr&#039;);
            if ($(e.currentTarget).data(&#039;state&#039;) === &#039;open&#039;) {
                $(e.currentTarget).data(&#039;state&#039;, &#039;closed&#039;).removeClass(&#039;group-desc&#039;).addClass(&#039;group-asc&#039;);
                accRow.nextUntil(&#039;.grouped_row_header&#039;).css(&#039;display&#039;, &#039;none&#039;);
            }
            else {
                $(e.currentTarget).data(&#039;state&#039;, &#039;open&#039;).removeClass(&#039;group-asc&#039;).addClass(&#039;group-desc&#039;);
                accRow.nextUntil(&#039;.grouped_row_header&#039;).css(&#039;display&#039;, &#039;table-row&#039;);
            }
        });
    }

    function makeCellEditable(id, td) {
        td.on(&#039;click&#039;, function editableCellClickHandler(e) {
            var gridContent = storage.grids[id].grid.find(&#039;.grid-content-div&#039;);
            var gridData = storage.grids[id];
            if (e.target !== e.currentTarget) return;
            if (gridContent.find(&#039;.invalid&#039;).length) return;
            var cell = $(e.currentTarget);
            cell.text(&#039;&#039;);

            if (storage.grids[id].updating) return;
            var index = cell.parents(&#039;tr&#039;).index(),
                field = cell.data(&#039;field&#039;),
                type = storage.grids[id].columns[field].type || &#039;&#039;,
                val = storage.grids[id].dataSource.data[index][field],
                dataAttributes = &#039;&#039;,
                gridValidation = storage.grids[id].useValidator ? storage.grids[id].columns[field].validation : null,
                dataType, input, inputVal;

            if (gridValidation) {
                dataAttributes = setupCellValidation(gridValidation, dataAttributes);
                var gridBodyId = &#039;grid-content-&#039; + id.toString();
                dataAttributes += &#039; data-validateon=&quot;blur&quot; data-offsetHeight=&quot;-6&quot; data-offsetWidth=&quot;8&quot; data-modalid=&quot;&#039; + gridBodyId + &#039;&quot;&#039;;
            }

            if (storage.grids[id].useFormatter &amp;&amp; storage.grids[id].columns[field].inputFormat)
                dataAttributes += &#039; data-inputformat=&quot;&#039; + storage.grids[id].columns[field].inputFormat + &#039;&quot;&#039;;

            switch (type) {
                case &#039;boolean&#039;:
                    input = $(&#039;&lt;input type=&quot;checkbox&quot; class=&quot;input checkbox active-cell&quot;&#039; + dataAttributes + &#039;/&gt;&#039;).appendTo(cell);
                    input[0].checked = typeof val === &#039;string&#039; ? val === &#039;true&#039; : !!val;
                    dataType = &#039;boolean&#039;;
                    break;
                case &#039;number&#039;:
                    inputVal = val;
                    input = $(&#039;&lt;input type=&quot;text&quot; value=&quot;&#039; + inputVal + &#039;&quot; class=&quot;input textbox cell-edit-input active-cell&quot;&#039; + dataAttributes + &#039;/&gt;&#039;).appendTo(cell);
                    dataType = &#039;number&#039;;
                    break;
                case &#039;time&#039;:
                    input = $(&#039;&lt;input type=&quot;text&quot; value=&quot;&#039; + val + &#039;&quot; class=&quot;input textbox cell-edit-input active-cell&quot;&#039; + dataAttributes + &#039;/&gt;&#039;).appendTo(cell);
                    dataType = &#039;time&#039;;
                    break;
                case &#039;date&#039;:
                    var dateVal = val === undefined ? new Date(Date.now()) : new Date(Date.parse(val));
                    inputVal = dateVal.toISOString().split(&#039;T&#039;)[0];
                    input = $(&#039;&lt;input type=&quot;date&quot; value=&quot;&#039; + inputVal + &#039;&quot; class=&quot;input textbox active-cell&quot;&#039; + dataAttributes + &#039;/&gt;&#039;).appendTo(cell);
                    dataType = &#039;date&#039;;
                    break;
                default:
                    input = $(&#039;&lt;input type=&quot;text&quot; value=&quot;&#039; + val + &#039;&quot; class=&quot;input textbox cell-edit-input active-cell&quot;&#039; + dataAttributes + &#039;/&gt;&#039;).appendTo(cell);
                    dataType = &#039;string&#039;;
                    break;
            }

            if (gridValidation) input.addClass(&#039;inputValidate&#039;);

            input[0].focus();

            if (dataType) {
                input.on(&#039;keypress&#039;, function restrictCharsHandler(e) {
                    var code = e.charCode ? e.charCode : e.keyCode;
                    if (!validateCharacter.call(this, code, dataType)) {
                        e.preventDefault();
                        return false;
                    }
                });
            }

            if (gridValidation &amp;&amp; dataAttributes !== &#039;&#039;) {
                attachValidationListener(input[0]);
            }
            else {
                input.on(&#039;blur&#039;, function cellEditBlurHandler() {
                    saveCellEditData(input);
                });
            }
            callGridEventHandlers(gridData.events.beforeCellEdit, gridData.grid, null);
        });
    }

    function makeCellSelectable(id, td) {
        td.on(&#039;click&#039;, function selectableCellClickHandler(e) {
            var gridContent = storage.grids[id].grid.find(&#039;.grid-content-div&#039;);
            var gridData = storage.grids[id];
            if (e.target !== e.currentTarget) return;
            if (gridContent.find(&#039;.invalid&#039;).length) return;
            var cell = $(e.currentTarget);
            cell.text(&#039;&#039;);
            var index = cell.parents(&#039;tr&#039;).index();
            var field = cell.data(&#039;field&#039;);
            if (storage.grids[id].updating) return;		

            var gridValidation = storage.grids[id].useValidator ? storage.grids[id].columns[field].validation : null;
            var dataAttributes = &#039;&#039;;

            if (gridValidation) {
                dataAttributes = setupCellValidation(gridValidation, dataAttributes);
                var gridBodyId = &#039;grid-content-&#039; + id.toString();
                dataAttributes += &#039; data-validateon=&quot;blur&quot; data-offsetHeight=&quot;-6&quot; data-offsetWidth=&quot;8&quot; data-modalid=&quot;&#039; + gridBodyId + &#039;&quot;&#039;;
            }

            var select = $(&#039;&lt;select class=&quot;input select active-cell&quot;&#039; + dataAttributes + &#039;&gt;&lt;/select&gt;&#039;).appendTo(cell);
            var options = [];
            var setVal = gridData.dataSource.data[index][field];
            options.push(setVal);
            for (var z = 0; z &lt; gridData.columns[field].options.length; z++) {
                if (setVal !== gridData.columns[field].options[z]) {
                    options.push(gridData.columns[field].options[z]);
                }
            }
            for (var k = 0; k &lt; options.length; k++) {
                var opt = $(&#039;&lt;option value=&quot;&#039; + options[k] + &#039;&quot;&gt;&#039; + options[k] + &#039;&lt;/option&gt;&#039;);
                select.append(opt);
            }
            select.val(setVal);
            select[0].focus();

            if (gridValidation) select.addClass(&#039;inputValidate&#039;);
            if (gridValidation &amp;&amp; dataAttributes !== &#039;&#039;) attachValidationListener(select[0]);
            else {
                select.on(&#039;blur&#039;, function cellEditBlurHandler() {
                    saveCellSelectData(select);
                });
            }
            callGridEventHandlers(gridData.events.beforeCellEdit, gridData.grid, null);
        });
    }

    function setupCellValidation(columnValidation, dataAttributes) {
        if (!grid.validation) {
            Object.defineProperty(
                grid,
                &#039;validation&#039;,
                { value: {}, writable: false }
            );
        }
        if (columnValidation.required) dataAttributes += &#039;data-required&#039;;
        if (columnValidation.customRules) {
            dataAttributes += &#039; data-customrules=&quot;&#039;;
            for (var rule in columnValidation.customRules) {
                dataAttributes += &#039;grid.validation.&#039; + rule + &#039;,&#039;;
                if (!grid.validation[rule]) {
                    Object.defineProperty(
                        grid.validation,
                        rule,
                        { value: columnValidation.customRules[rule], writable: false, configurable: false }
                    );
                }
            }
            dataAttributes += &#039;&quot;&#039;;
        }
        return dataAttributes;
    }

    function setColWidth(gridData, gridElem) {
        var columnNames = {},
            name,
            columnList = [];
        var tableDiv = gridElem.find(&#039;.grid-header-wrapper&#039;);
        for (name in gridData.columns) {
            columnNames[name] = isNumber(gridData.columns[name].width) ? gridData.columns[name].width : null;
            columnList.push(name);
        }
        var colGroups = tableDiv.find(&#039;col&#039;);

        colGroups.each(function iterateColsCallback(idx, val) {
            var i = idx;
            if (gridData.groupedBy &amp;&amp; gridData.groupedBy !== &#039;none&#039;) {
                i = (idx%(colGroups.length/2)) - 1;
            }
            if (gridData.groupedBy &amp;&amp; gridData.groupedBy !== &#039;none&#039; &amp;&amp; idx === 0) {
                $(val).css(&#039;width&#039;, 27);
            }
            else if (columnNames[columnList[i]] != null) {
                    $(val).css(&#039;width&#039;, columnNames[columnList[i]]);
            }
        });
    }

    function copyGridWidth(gridElem) {
        var headerCols = gridElem.find(&#039;.grid-header-div&#039;).find(&#039;col&#039;);
        var contentCols = gridElem.find(&#039;.grid-content-div&#039;).find(&#039;col&#039;);
        var headerTable = gridElem.find(&#039;.grid-header-div&#039;).find(&#039;table&#039;);
        var contentTable = gridElem.find(&#039;.grid-content-div&#039;).find(&#039;table&#039;);

        contentTable.css(&#039;width&#039;, headerTable[0].clientWidth);

        contentCols.each(function colIterationCallback(idx, val) {
            if ($(val).hasClass(&#039;group_col&#039;)) return;
            var width;
            if (width = $(headerCols[idx]).width()) $(val).css(&#039;width&#039;, width);
        });
    }

    function attachValidationListener(elem) {
        $(document).one(&#039;validated&#039;, function validationHandlerCallback(e, eventData) {
            if (eventData.element === elem) {
                if (eventData.succeeded &amp;&amp; elem.type !== &#039;select&#039; &amp;&amp; elem.type !== &#039;select-one&#039;)
                    saveCellEditData($(elem));
                else if (eventData.succeeded)
                    saveCellSelectData($(elem));
                else {
                    elem.focus();
                    attachValidationListener(elem);
                }
            }
            else attachValidationListener(elem);
        });
    }

    function saveCellEditData(input) {
        var val;
        if (input[0].type == &#039;checkbox&#039;) val = input.is(&#039;:checked&#039;);
        else val = input.val();
        var gridContent = input.parents(&#039;.grid-wrapper&#039;).find(&#039;.grid-content-div&#039;),
            cell = input.parents(&#039;td&#039;),
            id = gridContent.data(&#039;grid_content_id&#039;),
            index = cell.parents(&#039;tr&#039;).index(),
            field = cell.data(&#039;field&#039;),
            type = storage.grids[id].columns[field].type || &#039;&#039;,
            saveVal, re,
            displayVal = getFormattedCellText(id, field, val) || storage.grids[id].dataSource.data[index][field];

        input.remove();
        switch (type) {
            case &#039;number&#039;:
                re = new RegExp(dataTypes.number);
                if (!re.test(val)) val = storage.grids[id].currentEdit[field] || storage.grids[id].dataSource.data[index][field];
                saveVal = typeof storage.grids[id].dataSource.data[index][field] === &#039;string&#039; ? val : parseFloat(val.replace(&#039;,&#039;, &#039;&#039;));
                break;
            case &#039;date&#039;:
                saveVal = displayVal;   
                break;
            case &#039;time&#039;:
                re = new RegExp(dataTypes.time);
                if (!re.test(val)) val = storage.grids[id].currentEdit[field] || storage.grids[id].dataSource.data[index][field];
                saveVal = displayVal;   
                break;
            default: 		
                saveVal = val;
                break;
        }

        cell.text(displayVal);
        storage.grids[id].currentEdit[field] = null;
        var previousVal = storage.grids[id].dataSource.data[index][field];
        if (previousVal !== saveVal &amp;&amp; !(&#039;&#039; === saveVal &amp;&amp; undefined === previousVal)) {	
            storage.grids[id].dataSource.data[index][field] = saveVal;
            cell.prepend(&#039;&lt;span class=&quot;dirty&quot;&gt;&lt;/span&gt;&#039;);
        }
        else
            storage.grids[id].dataSource.data[index][field] = previousVal;
        callGridEventHandlers(storage.grids[id].events.afterCellEdit, storage.grids[id].grid, null);
    }

    function saveCellSelectData(select) {
        var gridContent = select.parents(&#039;.grid-wrapper&#039;).find(&#039;.grid-content-div&#039;),
            val = select.val(),
            parentCell = select.parents(&#039;td&#039;);
        select.remove();
        var id = gridContent.data(&#039;grid_content_id&#039;),
            index = parentCell.parents(&#039;tr&#039;).index(),
            field = parentCell.data(&#039;field&#039;),
            type = storage.grids[id].columns[field].type || &#039;&#039;,
            displayVal = getFormattedCellText(id, field, val) || storage.grids[id].dataSource.data[index][field],
            re, saveVal;

        switch (type) {
            case &#039;number&#039;:
                re = new RegExp(dataTypes.number);
                if (!re.test(val)) val = storage.grids[id].currentEdit[field] || storage.grids[id].dataSource.data[index][field];
                saveVal = typeof storage.grids[id].dataSource.data[index][field] === &#039;string&#039; ? val : parseFloat(val.replace(&#039;,&#039;, &#039;&#039;));
                break;
            case &#039;date&#039;:
                saveVal = displayVal;   
                break;
            case &#039;time&#039;:
                re = new RegExp(dataTypes.time);
                if (!re.test(val)) val = storage.grids[id].currentEdit[field] || storage.grids[id].dataSource.data[index][field];
                saveVal = displayVal;   
                break;
            default: 		
                saveVal = val;
                break;
        }

        parentCell.text(displayVal);
        var previousVal = storage.grids[id].dataSource.data[index][field];
        if (previousVal !== saveVal) {	
            parentCell.prepend(&#039;&lt;span class=&quot;dirty&quot;&gt;&lt;/span&gt;&#039;);
            storage.grids[id].dataSource.data[index][field] = saveVal;
        }
        callGridEventHandlers(storage.grids[id].events.afterCellEdit, storage.grids[id].grid, null);
    }

    function createCellEditSaveDiv(gridData, gridElem) {
        var id = gridElem.find(&#039;.grid-wrapper&#039;).data(&#039;grid_id&#039;);
        if ($(&#039;#grid_&#039; + id + &#039;_toolbar&#039;).length) return;	

        var saveBar = $(&#039;&lt;div id=&quot;grid_&#039; + id + &#039;_toolbar&quot; class=&quot;toolbar clearfix&quot; data-grid_id=&quot;&#039; + id + &#039;&quot;&gt;&lt;/div&gt;&#039;).prependTo(gridElem);

        if (gridData.excelExport) {
            var menuLink = $(&#039;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&#039;);
            menuLink.append(&#039;&lt;span class=&quot;menuSpan&quot;&gt;&lt;/span&gt;&#039;);
            saveBar.append(menuLink);
            attachMenuClickHandler(menuLink, id);
        }


        var saveAnchor = $(&#039;&lt;a href=&quot;#&quot; class=&quot;toolbarAnchor saveToolbar&quot;&gt;&lt;/a&gt;&#039;).appendTo(saveBar);
        saveAnchor.append(&#039;&lt;span class=&quot;toolbarSpan saveToolbarSpan&quot;&gt;&lt;/span&gt;Save Changes&#039;);

        var deleteAnchor = $(&#039;&lt;a href=&quot;#&quot; class=&quot;toolbarAnchor deleteToolbar&quot;&gt;&lt;/a&gt;&#039;).appendTo(saveBar);
        deleteAnchor.append(&#039;&lt;span class=&quot;toolbarSpan deleteToolbarSpan&quot;&gt;Delete Changes&lt;/span&gt;&#039;);

        saveAnchor.on(&#039;click&#039;, function saveChangesHandler() {
            if (storage.grids[id].updating) return;
            var dirtyCells = [],
                pageNum = storage.grids[id].pageNum, i;
            gridElem.find(&#039;.dirty&#039;).each(function iterateDirtySpansCallback(idx, val) {
                dirtyCells.push($(val).parents(&#039;td&#039;));
            });

            if (dirtyCells.length) {
                if (typeof storage.grids[id].dataSource.put !== &#039;function&#039;) {
                    for (i = 0; i &lt; dirtyCells.length; i++) {
                        var index = dirtyCells[i].parents(&#039;tr&#039;).index();
                        var field = dirtyCells[i].data(&#039;field&#039;);
                        var origIndex = storage.grids[id].dataSource.data[index][field]._initialRowIndex;
                        storage.grids[id].originalData[origIndex][field] = storage.grids[id].dataSource.data[index][field];
                        dirtyCells[i].find(&#039;.dirty&#039;).remove();
                    }
                }
                else {
                    storage.grids[id].putRequest.eventType = &#039;save&#039;;
                    storage.grids[id].putRequest.pageNum = pageNum;
                    storage.grids[id].putRequest.models = [];
                    var putRequestModels = storage.grids[id].putRequest.models;
                    for (i = 0; i &lt; dirtyCells.length; i++) {
                        var tmpModel = cloneGridData(storage.grids[id].dataSource.data[dirtyCells[i].parents(&#039;tr&#039;).index()]);
                        var tmpMap = tmpModel._initialRowIndex;
                        var idx = existsInPutRequest(putRequestModels, tmpModel);
                        if (~idx)
                            putRequestModels[idx].dirtyFields.push(dirtyCells[i].data(&#039;field&#039;));
                        else
                            putRequestModels.push({ cleanData: storage.grids[id].originalData[tmpMap], dirtyData: tmpModel, dirtyFields: [dirtyCells[i].data(&#039;field&#039;)] });
                    }

                    for (i = 0; i &lt; putRequestModels.length; i++) {
                        delete putRequestModels[i].dirtyData._initialRowIndex;
                    }

                    prepareGridDataUpdateRequest(id);
                }
            }
        });

        deleteAnchor.on(&#039;click&#039;, function deleteChangeHandler() {
            if (storage.grids[id].updating) return;
            var dirtyCells = [];
            gridElem.find(&#039;.dirty&#039;).each(function iterateDirtySpansCallback(idx, val) {
                dirtyCells.push($(val).parents(&#039;td&#039;));
            });

            if (dirtyCells.length) {
                for (var i = 0; i &lt; dirtyCells.length; i++) {
                    var field = dirtyCells[i].data(&#039;field&#039;);
                    var index = dirtyCells[i].parents(&#039;tr&#039;).index();
                    var pageNum = storage.grids[id].pageNum;
                    var rowNum = storage.grids[id].pageSize;
                    var addend = (pageNum-1)*rowNum;
                    var cellVal = storage.grids[id].originalData[index][field] !== undefined ? storage.grids[id].originalData[index][field] : &#039;&#039;;
                    var text = getFormattedCellText(id, field, cellVal) || cellVal;
                    dirtyCells[i].text(text);
                    dirtyCells[i].find(&#039;.dirty&#039;).remove();
                    storage.grids[id].dataSource.data[index][field] = storage.grids[id].originalData[index + addend][field];
                }
            }
        });

        if (gridData.groupable) {
            var groupSpan = $(&#039;&lt;span class=&quot;toolbarSpan group_span&quot; style=&quot;float:right;&quot;&gt;&lt;span class=&quot;groupTextSpan&quot; style=&quot;float:left;&quot;&gt;Group By: &lt;/span&gt;&lt;/span&gt;&#039;).appendTo(saveBar);
            var columnsList = $(&#039;&lt;select class=&quot;input select group_select&quot; style=&quot;float:none; display: inline; width: auto;&quot;&gt;&lt;/select&gt;&#039;).appendTo(groupSpan);
            var dirList = $(&#039;&lt;select class=&quot;input select group_dir_select&quot; style=&quot;display: inline; width: auto;&quot;&gt;&lt;/span&gt;&#039;).appendTo(groupSpan);
            dirList.append(&#039;&lt;option value=&quot;asc&quot;&gt;Ascending&lt;/span&gt;&#039;);
            dirList.append(&#039;&lt;option value=&quot;desc&quot;&gt;Descending&lt;/span&gt;&#039;);
            columnsList.append(&#039;&lt;option value=&quot;none&quot;&gt;None&lt;/option&gt;&#039;);
            for (var col in gridData.columns) {
                if (gridData.columns[col].groupable !== false) {
                    var colTitle = gridData.columns[col].title || col;
                    columnsList.append(&#039;&lt;option value=&quot;&#039; + col + &#039;&quot;&gt;&#039; + colTitle + &#039;&lt;/option&gt;&#039;);
                }
            }
            columnsList.on(&#039;change&#039;, groupByHandler);
            dirList.on(&#039;change&#039;, groupByHandler);
        }
    }

    function attachMenuClickHandler(menuAnchor, gridId) {
        menuAnchor.on(&#039;click&#039;, function menuAnchorClickHandler(e) {
            e.stopPropagation();	
            e.preventDefault();
            var grid = menuAnchor.parents(&#039;.grid-wrapper&#039;),
                menu = grid.find(&#039;#menu_id_&#039; + gridId),
                newMenu;

            if (!menu.length) {
                newMenu = $(&#039;&lt;div id=&quot;menu_model_grid_id_&#039; + gridId + &#039;&quot; class=&quot;grid_menu&quot;&gt;&lt;/div&gt;&#039;);
                var list = $(&#039;&lt;ul class=&quot;menu-list&quot;&gt;&lt;/ul&gt;&#039;);
                var groupElement = $(&#039;&lt;li class=&quot;menu_item&quot;&gt;&lt;/li&gt;&#039;);
                var groupAnchor = $(&#039;&lt;a href=&quot;#&quot; class=&quot;menu_anchor&quot;&gt;&lt;span class=&quot;excel_span&quot;&gt;Export to Excel&lt;span class=&quot;menu_arrow&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&#039;);
                groupElement.on(&#039;mouseover&#039;, function excelMenuItemHoverHandler() {
                    var exportOptions = storage.grids[gridId].grid.find(&#039;#excel_grid_id_&#039; + gridId);
                    if (!exportOptions.length) {
                        exportOptions = $(&#039;&lt;div id=&quot;excel_grid_id_&#039; + gridId + &#039;&quot; class=&quot;menu_item_options&quot;&gt;&lt;/div&gt;&#039;);
                        var exportList = $(&#039;&lt;ul class=&quot;menu-list&quot;&gt;&lt;/ul&gt;&#039;);
                        var gridPage = $(&#039;&lt;a href=&quot;#&quot; class=&quot;menu_anchor&quot;&gt;&lt;span class=&quot;excel_span&quot;&gt;Current Page Data&lt;/span&gt;&lt;/a&gt;&lt;br&gt;&#039;);
                        var gridSelection = $(&#039;&lt;a href=&quot;#&quot; class=&quot;menu_anchor&quot;&gt;&lt;span class=&quot;excel_span&quot;&gt;Selected Grid Data&lt;/span&gt;&lt;/a&gt;&#039;);
                        var allData = $(&#039;&lt;a href=&quot;#&quot; class=&quot;menu_anchor&quot;&gt;&lt;span class=&quot;excel_span&quot;&gt;All Page Data&lt;/span&gt;&lt;/a&gt;&lt;br&gt;&#039;);
                        exportList.append(gridPage).append(allData).append(gridSelection);
                        exportOptions.append(exportList);
                        storage.grids[gridId].grid.append(exportOptions);
                    }
                    else
                        exportOptions.removeClass(&#039;hidden_menu_item&#039;);

                    var groupAnchorOffset = groupAnchor.offset(),
                        newMenuOffset = newMenu.offset();
                    exportOptions.css(&#039;top&#039;, (groupAnchorOffset.top - $(window).scrollTop()));
                    exportOptions.css(&#039;left&#039;, (newMenuOffset.left + newMenu.outerWidth() - 1 - $(window).scrollLeft()));
                });
                groupElement.on(&#039;mouseout&#039;, function excelMenuItemHoverHandler(evt) {
                    var excelOptions = $(&#039;#excel_grid_id_&#039; + gridId),
                        excelOptionsOffset = excelOptions.offset();
                    if (evt.pageX &gt;= excelOptionsOffset.left &amp;&amp; evt.pageX &lt;= (excelOptionsOffset.left + excelOptions.width()) &amp;&amp; evt.pageY &gt;= excelOptionsOffset.top &amp;&amp;
                        evt.pageY &lt;= (excelOptionsOffset.top + excelOptions.height())) {
                        excelOptions.one(&#039;mouseleave&#039;, function(e) {
                            var groupElementOffset = groupElement.offset();
                            if (e.pageX &gt;= groupElementOffset.left &amp;&amp; e.pageX &lt;= (groupElementOffset.left + groupElement.outerWidth()) &amp;&amp; e.pageY &gt;= groupElementOffset.top &amp;&amp;
                                e.pageY &lt;= (groupElementOffset.top + groupElement.outerHeight())) return;
                            storage.grids[gridId].grid.find(&#039;#excel_grid_id_&#039; + gridId).addClass(&#039;hidden_menu_item&#039;);
                        });
                    }
                    else {
                        storage.grids[gridId].grid.find(&#039;#excel_grid_id_&#039; + gridId).addClass(&#039;hidden_menu_item&#039;);
                    }
                });
                groupElement.append(groupAnchor);
                list.append(groupElement);
                newMenu.append(list);
                storage.grids[gridId].grid.append(newMenu);
                $(document).on(&#039;click&#039;, function hideMenuHandler(e) {
                    var elem = $(e.target);
                    if (!elem.hasClass(&#039;grid_menu&#039;) &amp;&amp; !elem.hasClass(&#039;menu_item_options&#039;)) {
                        if (!elem.parents(&#039;.grid_menu&#039;).length &amp;&amp; !elem.parents(&#039;.menu_item_options&#039;).length) {
                            $(&#039;.grid_menu&#039;).addClass(&#039;hiddenMenu&#039;);
                        }
                    }
                });
            }
            else {
                newMenu = menu;
                newMenu.removeClass(&#039;hiddenMenu&#039;);
            }

            var menuAnchorOffset = menuAnchor.offset();
            newMenu.css(&#039;top&#039;, (menuAnchorOffset.top - $(window).scrollTop()));
            newMenu.css(&#039;left&#039;, (menuAnchorOffset.left - $(window).scrollLeft()));
        });
    }

    function groupByHandler() {
        var id = $(this).parents(&#039;.toolbar&#039;).data(&#039;grid_id&#039;);
        if (storage.grids[id].updating) return;
        var colSelector = $(this).parents(&#039;.toolbar&#039;).find(&#039;.group_select&#039;),
            directionSelector = $(this).parents(&#039;.toolbar&#039;).find(&#039;.group_dir_select&#039;);
        if (colSelector.val() === &#039;none&#039; &amp;&amp; (!storage.grids[id].groupedBy || storage.grids[id].groupedBy === &#039;none&#039;)) return;
        if (Object.keys(storage.grids[id].columns).length === storage.grids[id].grid.find(&#039;colgroup&#039;).first().find(&#039;col&#039;).length &amp;&amp; colSelector.val() !== &#039;none&#039;) {
            if (!storage.grids[id].groupedBy)
                storage.grids[id].groupingStatusChanged = true;
            var colGroups = storage.grids[id].grid.find(&#039;colgroup&#039;);
            colGroups.each(function iterateColGroupsForInsertCallback(idx, val) {
                $(val).prepend(&#039;&lt;col class=&quot;group_col&quot;/&gt;&#039;);
            });
            storage.grids[id].grid.find(&#039;.grid-headerRow&#039;).prepend(&#039;&lt;th class=&quot;group_spacer&quot;&gt;&amp;nbsp&lt;/th&gt;&#039;);
            storage.grids[id].grid.find(&#039;.summary-row-header&#039;).prepend(&#039;&lt;td class=&quot;group_spacer&quot;&gt;&amp;nbsp&lt;/td&gt;&#039;);
        }
        else if (colSelector.val() === &#039;none&#039;) {
            storage.grids[id].groupingStatusChanged = true;
            storage.grids[id].grid.find(&#039;colgroup&#039;).find(&#039;.group_col&#039;).remove();
            storage.grids[id].grid.find(&#039;.group_spacer&#039;).remove();
            storage.grids[id].alteredData = cloneGridData(storage.grids[id].originalData);
        }
        storage.grids[id].pageRequest.groupedBy = colSelector.val() === &#039;none&#039; ? undefined : colSelector.val();
        storage.grids[id].pageRequest.groupSortDirection = colSelector.val() === &#039;none&#039; ? undefined : directionSelector.val();
        storage.grids[id].pageRequest.eventType = &#039;group&#039;;
        preparePageDataGetRequest(id);
    }

    function createGridFooter(gridData, gridElem) {
        var gridFooter = gridElem.find(&#039;.grid-footer-div&#039;);
        var id = gridFooter.data(&#039;grid_footer_id&#039;);
        var count = storage.grids[id].dataSource.rowCount;
        var displayedRows = (count - storage.grids[id].pageSize) &gt; 0 ? storage.grids[id].pageSize : count;
        var remainingPages = (count - displayedRows) &gt; 0 ? Math.ceil((count - displayedRows)/displayedRows) : 0;
        var pageNum = storage.grids[parseInt(gridFooter.data(&#039;grid_footer_id&#039;))].pageNum;

        var first = $(&#039;&lt;a href=&quot;#&quot; class=&quot;grid-page-link link-disabled&quot; data-link=&quot;first&quot; data-pagenum=&quot;1&quot; title=&quot;First Page&quot;&gt;&lt;span class=&quot;grid-page-span span-first&quot;&gt;First Page&lt;/span&gt;&lt;/a&gt;&#039;).appendTo(gridFooter);
        var prev = $(&#039;&lt;a href=&quot;#&quot; class=&quot;grid-page-link link-disabled&quot; data-link=&quot;prev&quot; data-pagenum=&quot;1&quot; title=&quot;Previous Page&quot;&gt;&lt;span class=&quot;grid-page-span span-prev&quot;&gt;Prev Page&lt;/span&gt;&lt;/a&gt;&#039;).appendTo(gridFooter);
        var text = &#039;Page &#039; + storage.grids[parseInt(gridFooter.data(&#039;grid_footer_id&#039;))].pageNum + &#039;/&#039; + (remainingPages + 1);
        gridFooter.append(&#039;&lt;span class=&quot;grid-pagenum-span page-counter&quot;&gt;&#039; + text + &#039;&lt;/span&gt;&#039;);
        var next = $(&#039;&lt;a href=&quot;#&quot; class=&quot;grid-page-link&quot; data-link=&quot;next&quot; data-pagenum=&quot;2&quot; title=&quot;Next Page&quot;&gt;&lt;span class=&quot;grid-page-span span-next&quot;&gt;Next Page&lt;/span&gt;&lt;/a&gt;&#039;).appendTo(gridFooter);
        var last = $(&#039;&lt;a href=&quot;#&quot; class=&quot;grid-page-link&quot; data-link=&quot;last&quot; data-pagenum=&quot;&#039; + (remainingPages + 1) + &#039;&quot; title=&quot;Last Page&quot;&gt;&lt;span class=&quot;grid-page-span span-last&quot;&gt;Last Page&lt;/span&gt;&lt;/a&gt;&#039;).appendTo(gridFooter);

        if (!remainingPages) {
            first.addClass(&#039;link-disabled&#039;);
            prev.addClass(&#039;link-disabled&#039;);
            next.addClass(&#039;link-disabled&#039;);
            last.addClass(&#039;link-disabled&#039;);
        }

        var pageOptions = gridData.pagingOptions;
        if (pageOptions &amp;&amp; pageOptions.constructor === Array) {
            var sizeSelectorSpan = $(&#039;&lt;span class=&quot;page-size-span&quot;&gt;&lt;/span&gt;&#039;),
                sizeSelect = $(&#039;&lt;select class=&quot;size-selector input&quot;&gt;&lt;/select&gt;&#039;),
                numOptions = 0;
            for (var i = 0; i &lt; pageOptions.length; i++) {
                if (isNumber(parseFloat(pageOptions[i]))) {
                    sizeSelect.append(&#039;&lt;option value=&quot;&#039; + pageOptions[i] + &#039;&quot;&gt;&#039; + pageOptions[i] + &#039;&lt;/option&gt;&#039;);
                    numOptions++;
                }
            }
            if (numOptions) {
                sizeSelectorSpan.appendTo(gridFooter);
                sizeSelect.appendTo(sizeSelectorSpan);
            }
            sizeSelect.val(storage.grids[id].pageSize);
            sizeSelectorSpan.append(&#039;Rows per page&#039;);

            sizeSelect.on(&#039;change&#039;, function pageSizeSelectorClickHandler() {
                var pageSize = $(this).val();
                storage.grids[id].pageRequest.pageSize = parseInt(pageSize);
                storage.grids[id].pageRequest.eventType = &#039;pageSize&#039;;
                preparePageDataGetRequest(id);
            });
        }

        var rowStart = 1 + (displayedRows*(pageNum-1));
        var rowEnd = displayedRows*pageNum;
        text = rowStart + &#039; - &#039; + rowEnd + &#039; of &#039; + count + &#039; rows&#039;;
        gridFooter.append(&#039;&lt;span class=&quot;pageinfo&quot;&gt;&#039; + text + &#039;&lt;/span&gt;&#039;);

        setPagerEventListeners(gridFooter);
    }

    function setPagerEventListeners(gridFooter) {
        gridFooter.find(&#039;a&#039;).each(function iterateGridFooterAnchorsCallback(idx, val) {
            $(val).on(&#039;click&#039;, function gridFooterAnchorClickHandlerCallback(e) {
                e.preventDefault();
                var link = e.currentTarget.tagName === &#039;A&#039; ? $(e.currentTarget) : $(e.srcElement).parents(&#039;.grid-page-link&#039;);
                if (link.hasClass(&#039;link-disabled&#039;)) {	
                    return;
                }
                var gridFooter = link.parents(&#039;.grid-footer-div&#039;);
                var allPagers = gridFooter.find(&#039;a&#039;);
                var id = parseInt(link.parents(&#039;.grid-wrapper&#039;)[0].dataset.grid_id);
                if (storage.grids[id].updating) return;		
                var gridData = storage.grids[id];
                var pageSize = gridData.pageSize;
                var pagerInfo = gridFooter.find(&#039;.pageinfo&#039;);
                var pagerSpan = gridFooter.find(&#039;.grid-pagenum-span&#039;);
                var totalPages = (gridData.dataSource.rowCount - pageSize) &gt; 0 ? Math.ceil((gridData.dataSource.rowCount - pageSize)/pageSize) + 1 : 1;
                var pageNum = parseInt(link[0].dataset.pagenum);
                gridData.pageNum = pageNum;
                var rowStart = 1 + (pageSize * (pageNum - 1));
                var rowEnd = pageSize * pageNum;

                switch (link.data(&#039;link&#039;)) {
                    case &#039;first&#039;:
                        link.addClass(&#039;link-disable&#039;);
                        $(allPagers[1]).addClass(&#039;link-disabled&#039;)[0].dataset.pagenum = 1;
                        $(allPagers[2]).removeClass(&#039;link-disabled&#039;)[0].dataset.pagenum = pageNum + 1;
                        $(allPagers[3]).removeClass(&#039;link-disabled&#039;);
                        break;
                    case &#039;prev&#039;:
                        link[0].dataset.pagenum = pageNum - 1;
                        if (pageNum === 1) {
                            link.addClass(&#039;link-disabled&#039;);
                            $(allPagers[0]).addClass(&#039;link-disabled&#039;);
                        }
                        $(allPagers[2]).removeClass(&#039;link-disabled&#039;)[0].dataset.pagenum = pageNum + 1;
                        $(allPagers[3]).removeClass(&#039;link-disabled&#039;);
                        break;
                    case &#039;next&#039;:
                        rowEnd = gridData.dataSource.rowCount &lt; pageSize * pageNum ? gridData.dataSource.rowCount : pageSize * pageNum;
                        link[0].dataset.pagenum = pageNum + 1;
                        if (pageNum === totalPages) {
                            link.addClass(&#039;link-disabled&#039;);
                            $(allPagers[3]).addClass(&#039;link-disabled&#039;);
                        }
                        $(allPagers[0]).removeClass(&#039;link-disabled&#039;);
                        $(allPagers[1]).removeClass(&#039;link-disabled&#039;)[0].dataset.pagenum = pageNum - 1;
                        break;
                    case &#039;last&#039;:
                        rowEnd = gridData.dataSource.rowCount &lt; pageSize * pageNum ? gridData.dataSource.rowCount : pageSize * pageNum;
                        link.addClass(&#039;link-disabled&#039;);
                        $(allPagers[2]).addClass(&#039;link-disabled&#039;)[0].dataset.pagenum = pageNum;
                        $(allPagers[0]).removeClass(&#039;link-disabled&#039;);
                        $(allPagers[1]).removeClass(&#039;link-disabled&#039;)[0].dataset.pagenum = pageNum - 1;
                        break;
                }
                pagerSpan.text(&#039;Page &#039; + pageNum + &#039;/&#039; + totalPages);
                pagerInfo.text(rowStart + &#039; - &#039; + rowEnd + &#039; of &#039; + gridData.dataSource.rowCount + &#039; rows&#039;);
                gridData.grid.find(&#039;.grid-content-div&#039;).empty();
                gridData.pageRequest.eventType = &#039;page&#039;;
                gridData.pageRequest.pageNum = pageNum;
                preparePageDataGetRequest(id);
            });
        });
    }

    function attachFilterListener(filterElem) {
        filterElem.on(&#039;click&#039;, function filterClickCallback(e) {
            e.stopPropagation();	
            e.preventDefault();
            var filterAnchor = $(e.target);
            var filterCell = filterAnchor.parents(&#039;th&#039;);
            var type = filterAnchor.data(&#039;type&#039;);
            var grid = filterElem.parents(&#039;.grid-wrapper&#039;);
            var id = grid.data(&#039;grid_id&#039;);
            if (storage.grids[id].updating) return;		
            var filters = grid.find(&#039;.filter-div&#039;);
            var currFilter = null;
            var field = filterAnchor.data(&#039;field&#039;);
            var title = storage.grids[id].columns[field].title || null;

            if (filters.length) {
                filters.each(function iterateFiltersCallback(idx, val) {
                    var filter = $(val);
                    if (filter.data(&#039;parentfield&#039;) === filterAnchor.data(&#039;field&#039;)) {
                        filter.removeClass(&#039;hiddenFilter&#039;);
                        currFilter = $(val);
                    }
                    else filter.addClass(&#039;hiddenFilter&#039;);
                });
            }

            if (!currFilter) {
                createFilterDiv(type, field, grid, title);
                currFilter = grid.find(&#039;.filter-div&#039;);
            }
            var filterCellOffset = filterCell.offset();
            currFilter.css(&#039;top&#039;, (filterCellOffset.top + filterCell.height() - $(window).scrollTop()));
            currFilter.css(&#039;left&#039;, (filterCellOffset.left + filterCell.width() - $(window).scrollLeft()));
        });
    }

    function createFilterDiv(type, field, grid, title) {
        var filterDiv = $(&#039;&lt;div class=&quot;filter-div&quot; data-parentfield=&quot;&#039; + field + &#039;&quot; data-type=&quot;&#039; + type + &#039;&quot;&gt;&lt;/div&gt;&#039;).appendTo(grid);
        var domName = title ? title : type;
        var filterInput, resetButton, button,
            span = $(&#039;&lt;span class=&quot;filterTextSpan&quot;&gt;Filter rows where &#039; + domName + &#039; is:&lt;/span&gt;&#039;).appendTo(filterDiv),
            select = type !== &#039;boolean&#039; ? $(&#039;&lt;select class=&quot;filterSelect select&quot;&gt;&lt;/select&gt;&#039;).appendTo(filterDiv)
                .append(&#039;&lt;option value=&quot;eq&quot;&gt;Equal to:&lt;/option&gt;&#039;).append(&#039;&lt;option value=&quot;neq&quot;&gt;Not equal to:&lt;/option&gt;&#039;) : null;

        switch (type) {
            case &#039;number&#039;:
                select.append(&#039;&lt;option value=&quot;gte&quot;&gt;Greater than or equal to:&lt;/option&gt;&#039;);
                select.append(&#039;&lt;option value=&quot;gt&quot;&gt;Greater than:&lt;/option&gt;&#039;);
                select.append(&#039;&lt;option value=&quot;lte&quot;&gt;Less than or equal to:&lt;/option&gt;&#039;);
                select.append(&#039;&lt;option value=&quot;lt&quot;&gt;Less than:&lt;/option&gt;&#039;);
                filterInput = $(&#039;&lt;input type=&quot;text&quot; class=&quot;filterInput input&quot; id=&quot;filterInput&#039; + type + field + &#039;&quot;/&gt;&#039;).appendTo(filterDiv);
                break;
            case &#039;date&#039;:
            case &#039;time&#039;:
                select.append(&#039;&lt;option value=&quot;gte&quot;&gt;Equal to or later than:&lt;/option&gt;&#039;);
                select.append(&#039;&lt;option value=&quot;gt&quot;&gt;Later than:&lt;/option&gt;&#039;);
                select.append(&#039;&lt;option value=&quot;lte&quot;&gt;Equal to or before:&lt;/option&gt;&#039;);
                select.append(&#039;&lt;option value=&quot;lt&quot;&gt;Before:&lt;/option&gt;&#039;);
                var inputType = type === &#039;date&#039; ? &#039;date&#039; : &#039;text&#039;;
                filterInput = $(&#039;&lt;input type=&quot;&#039; + inputType + &#039;&quot; class=&quot;filterInput input&quot; id=&quot;filterInput&#039; + type + field + &#039;&quot;/&gt;&#039;).appendTo(filterDiv);
                break;
            case &#039;boolean&#039;:
                var optSelect = $(&#039;&lt;select class=&quot;filterSelect select&quot;&gt;&lt;/select&gt;&#039;).appendTo(span);
                optSelect.append(&#039;&lt;option value=&quot;true&quot;&gt;True&lt;/option&gt;&#039;);
                optSelect.append(&#039;&lt;option value=&quot;false&quot;&gt;False&lt;/option&gt;&#039;);
                break;
            case &#039;string&#039;:
                select.append(&#039;&lt;option value=&quot;ct&quot;&gt;Contains:&lt;/option&gt;&#039;);
                select.append(&#039;&lt;option value=&quot;nct&quot;&gt;Does not contain:&lt;/option&gt;&#039;);
                filterInput = $(&#039;&lt;input class=&quot;filterInput input&quot; type=&quot;text&quot; id=&quot;filterInput&#039; + type + field + &#039;&quot;/&gt;&#039;).appendTo(filterDiv);
                break;
        }
        resetButton = $(&#039;&lt;input type=&quot;button&quot; value=&quot;Reset&quot; class=&quot;button resetButton&quot; data-field=&quot;&#039; + field + &#039;&quot;/&gt;&#039;).appendTo(filterDiv);
        button = $(&#039;&lt;input type=&quot;button&quot; value=&quot;Filter&quot; class=&quot;filterButton button&quot; data-field=&quot;&#039; + field + &#039;&quot;/&gt;&#039;).appendTo(filterDiv);
        resetButton.on(&#039;click&#039;, resetButtonClickHandler);
        button.on(&#039;click&#039;, filterButtonClickHandler);
        if (filterInput &amp;&amp; type !==&#039;time&#039; &amp;&amp; type !== &#039;date&#039;) filterInputValidation(filterInput);
    }

    function filterInputValidation(input) {
        input.on(&#039;keypress&#039;, function restrictCharsHandler(e) {
            var code = e.charCode? e.charCode : e.keyCode,
                type = $(this).parents(&#039;.filter-div&#039;).data(&#039;type&#039;);
            if (!validateCharacter.call(this, code, type)) {
                e.preventDefault();
                return false;
            }
        });
    }

    function resetButtonClickHandler(e) {
        var filterDiv = $(e.currentTarget).parents(&#039;.filter-div&#039;);
        var value = filterDiv.find(&#039;.filterInput&#039;).val();
        var gridId = filterDiv.parents(&#039;.grid-wrapper&#039;).data(&#039;grid_id&#039;);
        if (storage.grids[gridId].updating) return;		
        var gridData = storage.grids[gridId];

        if (value === &#039;&#039; &amp;&amp; gridData.filterVal === &#039;&#039;) return;
        filterDiv.find(&#039;.filterInput&#039;).val(&#039;&#039;);

        filterDiv.addClass(&#039;hiddenFilter&#039;);

        gridData.pageRequest.filteredOn = null;
        gridData.pageRequest.filterVal = null;
        gridData.pageRequest.filterType = null;
        gridData.filteredOn = null;
        gridData.filterVal = null;
        gridData.filterType = null;
        gridData.pageRequest.eventType = &#039;filter&#039;;
        storage.grids[gridId].alteredData = cloneGridData(storage.grids[gridId].originalData);
        preparePageDataGetRequest(gridId);
    }

    function filterButtonClickHandler(e) {
        var filterDiv = $(e.currentTarget).parents(&#039;.filter-div&#039;),
            selected = filterDiv.find(&#039;.filterSelect&#039;).val(),
            value = filterDiv.find(&#039;.filterInput&#039;).val(),
            gridId = filterDiv.parents(&#039;.grid-wrapper&#039;).data(&#039;grid_id&#039;);
        if (storage.grids[gridId].updating) return;		
        var gridData = storage.grids[gridId],
            type = filterDiv.data(&#039;type&#039;),
            errors = filterDiv.find(&#039;.filter-div-error&#039;),
            re;

        if (dataTypes[type]) {
            re = new RegExp(dataTypes[type]);
            if (!re.test(value) &amp;&amp; !errors.length) {
                $(&#039;&lt;span class=&quot;filter-div-error&quot;&gt;Invalid &#039; + type + &#039;&lt;/span&gt;&#039;).appendTo(filterDiv);
                return;
            }
        }

        if (errors.length) errors.remove();
        if (value === &#039;&#039; &amp;&amp; gridData.filterVal === &#039;&#039;) return;

        filterDiv.addClass(&#039;hiddenFilter&#039;);
        gridData.pageRequest.filteredOn = $(this).data(&#039;field&#039;);
        gridData.pageRequest.filterVal = value;
        gridData.pageRequest.filterType = selected;
        gridData.pageRequest.eventType = &#039;filter&#039;;
        preparePageDataGetRequest(gridId);
    }

    function createGridColumnsFromArray(gridData, gridElem) {
        var headerCol = {};
        var index = 0;
        for (var i = 0; i &lt; gridData.length; i++) {
            for (var col in gridData[i]) {
                if (!headerCol[col]) {
                    headerCol[col] = {};
                    headerCol[col].field = col;
                    headerCol[col].title = col;
                    headerCol[col].reorderable = true;
                    headerCol[col].sortable = true;
                    index++;
                }
            }
        }
        var newGridData = {
            columns: headerCol,
            data: gridData
        };
        createGridHeaders(newGridData, gridElem);
    }

    function setDragAndDropListeners(elem) {
        elem.on(&#039;dragstart&#039;, function handleDragStartCallback(e) {
            e.originalEvent.dataTransfer.setData(&#039;text&#039;, e.currentTarget.id);
        });
        elem.on(&#039;drop&#039;, handleDropCallback);
        elem.on(&#039;dragover&#039;, function handleHeaderDragOverCallback(e) {
            e.preventDefault();
        });
        elem.on(&#039;mouseleave&#039;, mouseLeaveHandlerCallback);
    }

    function handleDropCallback(e) {
        var droppedCol = $(&#039;#&#039; + e.originalEvent.dataTransfer.getData(&#039;text&#039;));
        var targetCol = $(e.currentTarget);
        var id = targetCol.parents(&#039;.grid-header-div&#039;).length ? targetCol.parents(&#039;.grid-wrapper&#039;).data(&#039;grid_id&#039;) : null;
        var droppedId = droppedCol.parents(&#039;.grid-header-div&#039;).length ? droppedCol.parents(&#039;.grid-wrapper&#039;).data(&#039;grid_id&#039;) : null;
        if (!id || !droppedId || id !== droppedId) return;  
        if (storage.grids[id].updating) return;		
        if (droppedCol[0].cellIndex === targetCol[0].cellIndex) return;
        if (droppedCol[0].id === &#039;sliderDiv&#039;) return;

        var parentDiv = targetCol.parents(&#039;.grid-header-div&#039;);
        var parentDivId = parentDiv.data(&#039;grid_header_id&#039;);
        var gridWrapper = parentDiv.parent(&#039;.grid-wrapper&#039;);
        var colGroups = gridWrapper.find(&#039;colgroup&#039;);

        var droppedIndex = droppedCol[0].dataset.index;
        var targetIndex = targetCol[0].dataset.index;

        var droppedClone = droppedCol.clone(false, true);
        var targetClone = targetCol.clone(false, true);

        var droppedEvents = $._data(droppedCol[0], &#039;events&#039;);
        var targetEvents = $._data(targetCol[0], &#039;events&#039;);
        if (droppedEvents.click) setSortableClickListener(droppedClone);
        setDragAndDropListeners(droppedClone);
        if (targetEvents.click) setSortableClickListener(targetClone);
        setDragAndDropListeners(targetClone);

        if (droppedClone.find(&#039;.filterSpan&#039;).length) attachFilterListener(droppedClone.find(&#039;.filterSpan&#039;));
        if (targetClone.find(&#039;.filterSpan&#039;).length) attachFilterListener(targetClone.find(&#039;.filterSpan&#039;));

        droppedCol.replaceWith(targetClone);
        targetCol.replaceWith(droppedClone);
        droppedClone[0].dataset.index = targetIndex;
        targetClone[0].dataset.index = droppedIndex;

        swapContentCells(parentDivId, droppedIndex, targetIndex);

        var targetWidth = colGroups[0].children[droppedIndex].style.width;
        var droppedWidth = colGroups[0].children[targetIndex].style.width;

        colGroups[0].children[targetIndex].style.width = targetWidth;
        colGroups[0].children[droppedIndex].style.width = droppedWidth;
        colGroups[1].children[targetIndex].style.width = targetWidth;
        colGroups[1].children[droppedIndex].style.width = droppedWidth;

        var sumRow = parentDiv.find(&#039;.summary-row-header&#039;);
        if (sumRow.length) {
            var droppedColSum = null,
                targetColSum = null;
            sumRow.children().each(function iterateSumRowCellsCallback(idx, val) {
                if ($(val).data(&#039;field&#039;) === droppedCol.data(&#039;field&#039;)) droppedColSum = $(val);
                else if ($(val).data(&#039;field&#039;) === targetCol.data(&#039;field&#039;)) targetColSum = $(val);
            });
            if (droppedColSum.length &amp;&amp; targetColSum.length) {
                var droppedColSumClone = droppedColSum.clone(true, true);
                var targetColSumClone = targetColSum.clone(true, true);
                droppedColSum.replaceWith(targetColSumClone);
                targetColSum.replaceWith(droppedColSumClone);
            }
        }
        e.preventDefault();
        var evtObj = {
            element: storage.grids[id].grid,
            droppedColumn: droppedCol.data(&#039;field&#039;),
            targetColumn: targetCol.data(&#039;field&#039;),
            droppedIndex: droppedIndex,
            targetIndex: targetIndex
        };
        callGridEventHandlers(storage.grids[id].events.columnReorder, storage.grids[id].grid, evtObj);
    }

    function mouseLeaveHandlerCallback(e) {
        var target = $(e.currentTarget);
        var targetOffset = target.offset();
        var targetWidth = target.innerWidth();
        var mousePos = { x: e.originalEvent.pageX, y: e.originalEvent.pageY };
        var sliderDiv = $(&#039;#sliderDiv&#039;);

        if (Math.abs(mousePos.x - (targetOffset.left + targetWidth)) &lt; 10) {
            if (!sliderDiv.length) {
                var parentDiv = target.parents(&#039;.grid-header-wrapper&#039;);
                sliderDiv = $(&#039;&lt;div id=sliderDiv style=&quot;width:10px; height:&#039; + target.innerHeight() + &#039;px; cursor: col-resize; position: absolute&quot; draggable=true&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&#039;).appendTo(parentDiv);
                sliderDiv.on(&#039;dragstart&#039;, function handleResizeDragStartCallback(e) {
                    e.originalEvent.dataTransfer.setData(&#039;text&#039;, e.currentTarget.id);
                    storage.grids[parentDiv.parent().data(&#039;grid_header_id&#039;)].resizing = true;
                });
                sliderDiv.on(&#039;dragend&#039;, function handleResizeDragEndCallback() {
                    storage.grids[parentDiv.parent().data(&#039;grid_header_id&#039;)].resizing = false;
                });
                sliderDiv.on(&#039;dragover&#039;, function handleResizeDragOverCallback(e) {
                    e.preventDefault();
                });
                sliderDiv.on(&#039;drop&#039;, function handleResizeDropCallback(e) {
                    e.preventDefault();
                });
                sliderDiv.on(&#039;drag&#039;, handleResizeDragCallback);
            }
            sliderDiv.data(&#039;targetindex&#039;, target[0].id);
            sliderDiv.css(&#039;top&#039;, targetOffset.top + &#039;px&#039;);
            sliderDiv.css(&#039;left&#039;, (targetOffset.left + targetWidth -4) + &#039;px&#039;);
            sliderDiv.css(&#039;position&#039;, &#039;absolute&#039;);
        }
    }

    function setSortableClickListener(elem) {
        elem.on(&#039;click&#039;, function handleHeaderClickCallback() {
            var headerDiv = elem.parents(&#039;.grid-header-div&#039;);
            var id = parseInt(headerDiv.data(&#039;grid_header_id&#039;));
            if (storage.grids[id].updating) return;		
            var field = elem.data(&#039;field&#039;),
                foundColumn = false;

            if (storage.grids[id].groupedBy &amp;&amp; storage.grids[id].groupedBy === field) return;   

            for (var i = 0; i &lt; storage.grids[id].sortedOn.length; i++) {
                if (storage.grids[id].sortedOn[i].field === field) {
                    foundColumn = true;
                    if (storage.grids[id].sortedOn[i].sortDirection === &#039;asc&#039;) {
                        storage.grids[id].sortedOn[i].sortDirection = &#039;desc&#039;;
                        elem.find(&#039;.sortSpan&#039;).addClass(&#039;sort-desc&#039;).removeClass(&#039;sort-asc&#039;);
                    }
                    else {
                        storage.grids[id].sortedOn =  storage.grids[id].sortedOn.filter(function filterSortedColumns(item) {
                            return item.field !== field;
                        });
                        elem.find(&#039;.sortSpan&#039;).remove();
                        storage.grids[id].alteredData = cloneGridData(storage.grids[id].originalData);
                    }
                }
            }

            if (!foundColumn) {
                storage.grids[id].sortedOn.push({ field: field, sortDirection: &#039;asc&#039; });
                elem.find(&#039;.header-anchor&#039;).append(&#039;&lt;span class=&quot;sort-asc sortSpan&quot;&gt;Sort&lt;/span&gt;&#039;);
            }
            storage.grids[id].pageRequest.sortedOn = storage.grids[id].sortedOn;
            storage.grids[id].pageRequest.eventType = &#039;sort&#039;;
            preparePageDataGetRequest(id);
        });
    }

    function setFilterableClickListener(elem, gridData, col) {
        var type = gridData.columns[col].type || &#039;string&#039;;
        var anchor = $(&#039;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&#039;).appendTo(elem);
        anchor.append(&#039;&lt;span class=&quot;filterSpan&quot; data-type=&quot;&#039; + type + &#039;&quot; data-field=&quot;&#039; + elem.data(&#039;field&#039;) + &#039;&quot;&gt;&lt;/span&gt;&#039;);
        attachFilterListener(anchor);
        if ($(document).find(&#039;.filterSpan&#039;).length &lt; 2) {
            $(document).on(&#039;click&#039;, function hideFilterHandler(e) {
                if (!$(e.target).hasClass(&#039;filter-div&#039;)) {
                    if ($(e.target).parents(&#039;.filter-div&#039;).length &lt; 1) {
                        $(document).find(&#039;.filter-div&#039;).each(function iterateFilterDivsCallback(idx, val) {
                            if ($(val).find(&#039;.filterInput&#039;).length)
                                $(val).find(&#039;.filterInput&#039;).val(&#039;&#039;);
                            $(val).addClass(&#039;hiddenFilter&#039;);
                        });
                    }
                }
            });
        }
        $(document).on(&#039;scroll&#039;, function scrollFilterHandler() {
            $(document).find(&#039;.filter-div&#039;).each(function iterateFilterDivsCallback(idx, val) {
                var filter = $(val);
                if (!filter.hasClass(&#039;hiddenFilter&#039;)) {
                    var gridWrapper = filter.parents(&#039;.grid-wrapper&#039;);
                    var filterCell = gridWrapper.find(&#039;th&#039;).filter(function headerIterationCallback(idx, val) {
                        return $(val).data(&#039;field&#039;) === filter.data(&#039;parentfield&#039;);
                    });
                    var filterCellOffset = filterCell.offset();
                    filter.css(&#039;top&#039;, (filterCellOffset.top + filterCell.height() - $(window).scrollTop()));
                    filter.css(&#039;left&#039;, (filterCellOffset.left + filterCell.width() - $(window).scrollLeft()));
                }
            });
        });
    }

    function handleResizeDragCallback(e) {
        e.preventDefault();
        var sliderDiv = $(e.currentTarget);
        var id = sliderDiv.parents(&#039;.grid-wrapper&#039;).data(&#039;grid_id&#039;);
        if (storage.grids[id].updating) return;		
        var targetCell = document.getElementById(sliderDiv.data(&#039;targetindex&#039;));
        var targetBox = targetCell.getBoundingClientRect();
        var endPos = e.originalEvent.pageX;
        var startPos = targetBox.left;
        var width = endPos - startPos;
        var space = endPos - targetBox.right;

        if (width &gt; 11) {
            var index = targetCell.dataset.index;
            var gridWrapper = $(targetCell).parents(&#039;.grid-wrapper&#039;);
            var colGroups = gridWrapper.find(&#039;colgroup&#039;);
            var tables = gridWrapper.find(&#039;table&#039;);
            if (storage.grids[id].groupedBy &amp;&amp; storage.grids[id].groupedBy !== &#039;none&#039;)
                index++;

            var contentDiv = gridWrapper.find(&#039;.grid-content-div&#039;);
            var scrollLeft = contentDiv.scrollLeft();
            var clientWidth = contentDiv[0].clientWidth;
            var scrollWidth = contentDiv[0].scrollWidth;
            var add = scrollLeft + clientWidth;
            var isTrue = add === scrollWidth;

            if (space &lt; 0 &amp;&amp; scrollWidth &gt; clientWidth &amp;&amp; isTrue) {
                space -= -3;
                width -= -3;
            }

            for (var i = 0; i &lt; colGroups.length; i++) {
                var currWidth = $(tables[i]).width();
                $(colGroups[i].children[index]).width(width);
                $(tables[i]).width(currWidth + space);

            }
            sliderDiv.css(&#039;left&#039;, e.originalEvent.pageX + &#039;px&#039;);
        }
    }

    function swapContentCells(gridId, droppedIndex, targetIndex) {
        var gridData = storage.grids[gridId];
        $(&#039;#grid-content-&#039; + gridId).find(&#039;tr&#039;).each(function iterateContentRowsCallback(idx, val) {
            if ($(val).hasClass(&#039;grouped_row_header&#039;))
                return true;
            var droppedIdx = 1 + parseInt(droppedIndex);
            var targetIdx = 1 + parseInt(targetIndex);
            if (gridData.groupedBy &amp;&amp; gridData.groupedBy !== &#039;none&#039;) {
                droppedIdx++;
                targetIdx++;
            }
            var droppedCell = $(val).children(&#039;td:nth-child(&#039; + droppedIdx + &#039;)&#039;);
            var targetCell = $(val).children(&#039;td:nth-child(&#039; + targetIdx + &#039;)&#039;);

            var droppedClone = droppedCell.clone(true, true);
            var targetClone = targetCell.clone(true, true);
            targetCell.replaceWith(droppedClone);
            droppedCell.replaceWith(targetClone);

            droppedClone[0].dataset.index = targetIndex;
            targetClone[0].dataset.index = droppedIndex;
        });
    }

    function preparePageDataGetRequest(id) {
        storage.grids[id].updating = true;
        var gridData = storage.grids[id];
        var pageNum = gridData.pageRequest.pageNum || gridData.pageNum;
        var pageSize = gridData.pageRequest.pageSize || gridData.pageSize;
        var sortedOn = gridData.sortedOn.length ? gridData.sortedOn : [];
        var filteredOn = gridData.pageRequest.filteredOn || gridData.filteredOn || null;
        var filterVal = gridData.pageRequest.filterVal || gridData.filterVal || null;
        var filterType = gridData.pageRequest.filterType || gridData.filterType || null;
        var groupedBy = gridData.pageRequest.eventType === &#039;group&#039; ? gridData.pageRequest.groupedBy : gridData.groupedBy || null;
        var groupSortDirection = gridData.pageRequest.eventType === &#039;group&#039; ? gridData.pageRequest.groupSortDirection : gridData.groupSortDirection || null;

        var requestObj = {};
        if (gridData.sortable) requestObj.sortedOn = sortedOn;

        if (gridData.filterable) {
            requestObj.filteredOn = filteredOn;
            requestObj.filterVal = filterVal;
            requestObj.filterType = filterType;
        }

        if (gridData.groupable) {
            requestObj.groupedBy = groupedBy;
            requestObj.groupSortDirection = groupSortDirection;
        }

        requestObj.pageSize = pageSize;
        requestObj.pageNum = gridData.eventType === &#039;filter&#039; ? 1 : pageNum;

        gridData.grid.find(&#039;.grid-content-div&#039;).empty();

        callGridEventHandlers(storage.grids[id].events.pageRequested, gridData.grid, { element: gridData.grid });

        if (gridData.dataSource.get &amp;&amp; typeof gridData.dataSource.get === &#039;function&#039;)
            gridData.dataSource.get(requestObj, getPageDataRequestCallback);
        else {
            if (!gridData.alteredData) gridData.alteredData = cloneGridData(gridData.originalData);
            getPageData(requestObj, id, getPageDataRequestCallback);
        }

        function getPageDataRequestCallback(response) {
            var groupingStatus = gridData.groupingStatusChanged;
            if (response) {
                gridData.dataSource.data = response.data;
                gridData.pageSize = requestObj.pageSize;
                gridData.pageNum = requestObj.pageNum;
                gridData.dataSource.rowCount = response.rowCount != null ? response.rowCount : response.length;
                gridData.groupedBy = requestObj.groupedBy;
                gridData.groupSortDirection = requestObj.groupSortDirection;
                gridData.sortedOn = requestObj.sortedOn;
                gridData.filteredOn = requestObj.filteredOn;
                gridData.filterVal = requestObj.filterVal;
                gridData.filterType = requestObj.filterType;
                gridData.groupingStatusChanged = false;

                if (gridData.pageRequest.eventType === &#039;newGrid&#039; || groupingStatus)
                    setColWidth(gridData, storage.grids[id].grid);

                createGridContent(gridData, storage.grids[id].grid);
                if (gridData.pageRequest.eventType === &#039;filter&#039; || gridData.pageRequest.eventType === &#039;pageSize&#039;) {
                    gridData.grid.find(&#039;.grid-footer-div&#039;).empty();
                    createGridFooter(gridData, gridData.grid);
                }
                if (gridData.pageRequest.eventType === &#039;filter&#039; &amp;&amp; gridData.summaryRow &amp;&amp; gridData.summaryRow.positionAt === &#039;top&#039;)
                    buildHeaderAggregations(gridData, id);
                gridData.pageRequest = {};
            }
        }
    }

    function prepareGridDataUpdateRequest(id) {
        storage.grids[id].updating = true;
        var requestObj = {
            models: storage.grids[id].putRequest.models,
            pageNum: storage.grids[id].putRequest.pageNum
        };

        storage.grids[id].dataSource.put(requestObj, updatePageDataPutRequestCallback);

        function updatePageDataPutRequestCallback(response) {
            storage.grids[id].updating = false;
            if (response) {
                storage.grids[id].grid.find(&#039;.dirty&#039;).each(function iterateDirtySpansCallback(idx, val) {
                    var index = $(val).parents(&#039;tr&#039;).index();
                    var field = $(val).parents(&#039;td&#039;).data(&#039;field&#039;);
                    var origIdx = storage.grids[id].dataSource.data[index]._initialRowIndex;
                    storage.grids[id].originalData[origIdx][field] = storage.grids[id].dataSource.data[index][field];
                    $(val).remove();
                });
            }
            else {
                storage.grids[id].grid.find(&#039;.dirty&#039;).each(function iterateDirtySpansCallback(idx, val) {
                    var cell = $(val).parents(&#039;td&#039;);
                    var index = cell.parents(&#039;tr&#039;).index();
                    var field = cell.data(&#039;field&#039;);
                    var text = getFormattedCellText(id, cell.data(&#039;field&#039;), storage.grids[id].originalData[index][field]) || storage.grids[id].originalData[index][field];
                    cell.text(text);
                    $(val).remove();
                });
            }
        }
    }

    function getPageData(requestObj, id, callback) {
        var eventType = storage.grids[id].pageRequest.eventType;
        var fullGridData = cloneGridData(storage.grids[id].alteredData);

        if (eventType === &#039;page&#039; || eventType === &#039;pageSize&#039; || eventType === &#039;newGrid&#039;) {
            limitPageData(requestObj, fullGridData, callback);
            return;
        }

        if (requestObj.filteredOn) {
            if (requestObj.filterVal !== &#039;&#039;) {
                var dataType = storage.grids[id].columns[requestObj.filteredOn].type || &#039;string&#039;;
                fullGridData = filterGridData(requestObj.filterType, requestObj.filterVal, requestObj.filteredOn, dataType, cloneGridData(storage.grids[id].originalData));
            }
            else fullGridData = cloneGridData(storage.grids[id].originalData);
            requestObj.pageNum = 1;		
            storage.grids[id].alteredData = fullGridData;
        }

        if (requestObj.groupedBy) {
            var groupedData = sortGridData([{ field: requestObj.groupedBy, sortDirection: requestObj.groupSortDirection }], fullGridData || cloneGridData(storage.grids[id].originalData), id);
            if (requestObj.sortedOn.length) {
                var sortedGroup = [];
                for (var group in groupedData.groupings) {
                    sortedGroup = sortedGroup.concat(sortGridData(requestObj.sortedOn, groupedData.groupings[group] || cloneGridData(storage.grids[id].originalData), id));
                }
                storage.grids[id].alteredData = fullGridData;
                limitPageData(requestObj, sortedGroup, callback);
                return;
            }
            storage.grids[id].alteredData = groupedData;
            limitPageData(requestObj, groupedData, callback);
            return;
        }

        if (requestObj.sortedOn.length &amp;&amp; !requestObj.groupedBy)
            fullGridData = sortGridData(requestObj.sortedOn, fullGridData || cloneGridData(storage.grids[id].originalData), id);
        storage.grids[id].alteredData = fullGridData;
        limitPageData(requestObj, fullGridData, callback);
    }


    function limitPageData(requestObj, fullGridData, callback) {
        var returnData;
        if (requestObj.pageSize &gt;= fullGridData.length)
            returnData = fullGridData;
        else {
            returnData = [];
            var startRow = (requestObj.pageNum-1) * (requestObj.pageSize);
            var endRow = fullGridData.length &gt;= (startRow + parseInt(requestObj.pageSize)) ? (startRow + parseInt(requestObj.pageSize)) : fullGridData.length;

            for (var i = startRow; i &lt; endRow; i++){
                returnData.push(fullGridData[i]);
            }
        }

        callback({ rowCount: fullGridData.length, data: returnData });
    }

    function filterGridData(filterType, value, field, dataType, gridData) {
        var filteredData = [], curVal, baseVal;

        for (var i = 0, length = gridData.length; i &lt; length; i++) {
            if (dataType === &#039;time&#039;) {
                curVal = getNumbersFromTime(gridData[i][field]);
                baseVal = getNumbersFromTime(value);

                if (gridData[i][field].indexOf(&#039;PM&#039;) &gt; -1) curVal[0] += 12;
                if (value.indexOf(&#039;PM&#039;) &gt; -1) baseVal[0] += 12;

                curVal = convertTimeArrayToSeconds(curVal);
                baseVal = convertTimeArrayToSeconds(baseVal);
            }
            else if (dataType === &#039;number&#039;) {
                curVal = parseFloat(gridData[i][field]);
                baseVal = parseFloat(value);
            }
            else if (dataType === &#039;date&#039;) {
                curVal = new Date(gridData[i][field]);
                baseVal = new Date(value);
            }
            else {
                curVal = gridData[i][field];
                baseVal = value;
            }
            if (comparator(curVal, baseVal, filterType)) filteredData.push(gridData[i]);
        }
    }

    function comparator(val, base, type) {
        switch (type) {
            case &#039;eq&#039;:
                return val === base;
            case &#039;neq&#039;:
                return val !== base;
            case &#039;gte&#039;:
                return val &gt;= base;
            case &#039;gt&#039;:
                return val &gt; base;
            case &#039;lte&#039;:
                return val &lt;= base;
            case &#039;lt&#039;:
                return val &lt; base;
            case &#039;ct&#039;:
                return !!~val.toLowerCase().indexOf(base.toLowerCase());
            case &#039;nct&#039;:
                return !~val.toLowerCase().indexOf(base.toLowerCase());
        }
    }

    function sortGridData (sortedItems, gridData, gridId) {
        for (var i = 0; i &lt; sortedItems.length; i++) {
            if (i === 0)
                gridData = mergeSort(gridData, sortedItems[i], storage.grids[gridId].columns[sortedItems[i].field].type || &#039;string&#039;);
            else {
                var sortedGridData = [];
                var itemsToSort = [];
                for (var j = 0; j &lt; gridData.length; j++) {
                    if (!itemsToSort.length || compareValuesByType(itemsToSort[0][sortedItems[i - 1].field], gridData[j][sortedItems[i - 1].field], storage.grids[gridId].columns[sortedItems[i - 1].field].type))
                        itemsToSort.push(gridData[j]);
                    else {
                        if (itemsToSort.length === 1) sortedGridData = sortedGridData.concat(itemsToSort);
                        else sortedGridData = sortedGridData.concat(mergeSort(itemsToSort, sortedItems[i], storage.grids[gridId].columns[sortedItems[i].field].type || &#039;string&#039;));
                        itemsToSort.length = 0;
                        itemsToSort.push(gridData[j]);
                    }
                    if (j === gridData.length - 1)
                        sortedGridData = sortedGridData.concat(mergeSort(itemsToSort, sortedItems[i], storage.grids[gridId].columns[sortedItems[i].field].type || &#039;string&#039;));
                }
                gridData = sortedGridData;
            }
        }
        return gridData;
    }

    function mergeSort(data, sortObj, type) {
        if (data.length &lt; 2) return data;
        var middle = parseInt(data.length / 2);
        var left   = data.slice(0, middle);
        var right  = data.slice(middle, data.length);
        return merge(mergeSort(left, sortObj, type), mergeSort(right, sortObj, type), sortObj, type);
    }

    function merge(left, right, sortObj, type) {
        var result = [], leftVal, rightVal;
        while (left.length &amp;&amp; right.length) {
            if (type === &#039;time&#039;) {
                leftVal = getNumbersFromTime(left[0][sortObj.field]);
                rightVal = getNumbersFromTime(right[0][sortObj.field]);

                if (~left[0][sortObj.field].indexOf(&#039;PM&#039;))
                    leftVal[0] += 12;
                if (~right[0][sortObj.field].indexOf(&#039;PM&#039;))
                    rightVal[0] += 12;

                leftVal = convertTimeArrayToSeconds(leftVal);
                rightVal = convertTimeArrayToSeconds(rightVal);
            }
            else if (type === &#039;number&#039;) {
                leftVal = parseFloat(left[0][sortObj.field]);
                rightVal = parseFloat(right[0][sortObj.field]);
            }
            else if (type === &#039;date&#039;) {
                leftVal = new Date(left[0][sortObj.field]);
                rightVal = new Date(right[0][sortObj.field]);
            }
            else {
                leftVal = left[0][sortObj.field];
                rightVal = right[0][sortObj.field];
            }
            var operator = sortObj.sortDirection === &#039;asc&#039; ? &#039;lte&#039; : &#039;gte&#039;;
            comparator(leftVal, rightVal, operator) ? result.push(left.shift()) : result.push(right.shift());
        }

        while (left.length)
            result.push(left.shift());

        while (right.length)
            result.push(right.shift());

        return result;
    }

    function callGridEventHandlers(events, context, param) {
        if (events.length) {
            for (var x = 0; x &lt; events.length; x++)
                events[x].call(context, param);
        }
    }

    function existsInPutRequest(putRequest, model) {
        for (var i = 0; i &lt; putRequest.length; i++) {
            if (model._initialRowIndex == putRequest[i].dirtyData._initialRowIndex)
                return i;
        }
        return -1;
    }

    function getFormattedCellText(gridId, column, value) {
        var text;
        switch(storage.grids[gridId].columns[column].type) {
            case &#039;number&#039;:
                text = formatNumericCellData(value, storage.grids[gridId].columns[column].format);
                break;
            case &#039;date&#039;:
                text = formatDateCellData(value, storage.grids[gridId].columns[column].format);
                break;
            case &#039;time&#039;:
                text = formatTimeCellData(value, column, gridId);
                break;
            case &#039;string&#039;:
            case &#039;boolean&#039;:
                text = value;
                break;
            default:
                text = value;
        }

        var template = storage.grids[gridId].columns[column].template;
        if (template &amp;&amp; text !== &#039;&#039;) {
            if (typeof template === &#039;function&#039;)
                return template.call(column, text);
            else if (typeof template === &#039;string&#039;)
                return template.replace(&#039;{{data}}&#039;, text);
            return text;
        }
        return text;
    }

    function getNumbersFromTime(val) {
        var re = new RegExp(dataTypes.time);
        if (!re.test(val)) return [];
        var timeGroups = re.exec(val);
        var hours = timeGroups[1] ? +timeGroups[1] : +timeGroups[6];
        var minutes, seconds, meridiem, retVal = [];
        if (timeGroups[2]) {
            minutes = +timeGroups[3] || 0;
            seconds = +timeGroups[4]  || 0;
            meridiem = timeGroups[5].replace(&#039; &#039;, &#039;&#039;) || null;
        }
        else if (timeGroups[6]) {
            minutes = +timeGroups[8] || 0;
            seconds = +timeGroups[9] || 0;
        }
        else{
            minutes = 0;
            seconds = 0;
        }
        retVal.push(hours);
        retVal.push(minutes);
        retVal.push(seconds);
        if (meridiem) retVal.push(meridiem);
        return retVal;
    }

    function convertTimeArrayToSeconds(timeArray) {
        var hourVal = timeArray[0] === 12 || timeArray[0] === 24 ? timeArray[0] - 12 : timeArray[0];
        return 3660 * hourVal + 60*timeArray[1] + timeArray[2];
    }

    function validateCharacter(code, dataType) {
        var key = String.fromCharCode(code);
        if (dataTypes[dataType]) {
            var re = new RegExp(dataTypes[dataType + &#039;Char&#039;]);
            return re.test(key);
        }
        return true;
    }

    function compareValuesByType (val1, val2, dataType) {
        switch (dataType) {
            case &#039;string&#039;:
                return val1.toString() === val2.toString();
            case &#039;number&#039;:
                return parseFloat(val1.toString()) === parseFloat(val2.toString());
            case &#039;boolean&#039;:
                return !!val1 === !!val2;
            case &#039;date&#039;:
                var date1 = new Date(val1),
                    date2 = new Date(val2);
                if (typeof date1 === &#039;object&#039; &amp;&amp; typeof date2 === &#039;object&#039; &amp;&amp; date1 !== date1 &amp;&amp; date2 !== date2)
                    return true;    
                return date1 === date2;
            case &#039;time&#039;:
                var value1 = getNumbersFromTime(val1);
                var value2 = getNumbersFromTime(val2);
                if (value1[3] &amp;&amp; value1[3] === &#039;PM&#039;)
                    value1[0] += 12;
                if (value2[3] &amp;&amp; value2[3] === &#039;PM&#039;)
                    value2[0] += 12;
                return convertTimeArrayToSeconds(value1) === convertTimeArrayToSeconds(value2);
            default:
                return val1.toString() === val2.toString();
        }
    }

    function exportDataAsExcelFile(table) {

        var excel = &quot;&lt;html xmlns:o=&#039;urn:schemas-microsoft-com:office:office&#039; xmlns:x=&#039;urn:schemas-microsoft-com:office:excel&#039; xmlns=&#039;http://www.w3.org/TR/REC-html40&#039;&gt;&quot;;
        excel += &quot;&lt;head&gt;&quot;;
        excel += &#039;&lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html;&quot; /&gt;&#039;;
        excel += &quot;&lt;/head&gt;&quot;;
        excel += &quot;&lt;body&gt;&quot;;
        excel += table.replace(/&quot;/g, &#039;\&#039;&#039;);
        excel += &quot;&lt;/body&gt;&quot;;
        excel += &quot;&lt;/html&gt;&quot;;

        var uri = &quot;data:application/vnd.ms-excel;base64,&quot;;
        var ctx = { worksheet: &#039;test&#039;, table: table };

        return window.open((uri + base64(format(excel, ctx))));
    }



    function base64(s) {
        return window.btoa(decodeURIComponent(encodeURIComponent(s)));
    }

    function format(s, c) {
        return s.replace(/{(\w+)}/g, function (m, p) { return c[p]; });
    }

    dataTypes = {
        number: &#039;^-?(?:[1-9]{1}[0-9]{0,2}(?:,[0-9]{3})*(?:\\.[0-9]+)?|[1-9]{1}[0-9]{0,}(?:\\.[0-9]+)?|0(?:\\.[0-9]+)?|(?:\\.[0-9]+)?)$&#039;,
        numberChar: &#039;[\\d,\\.-]&#039;,
        integer: &#039;^\\-?\\d+$&#039;,
        time: &#039;^(0?[1-9]|1[012])(?:(?:(:|\\.)([0-5]\\d))(?:\\2([0-5]\\d))?)?(?:(\\ [AP]M))$|^([01]?\\d|2[0-3])(?:(?:(:|\\.)([0-5]\\d))(?:\\7([0-5]\\d))?)$&#039;,
        timeChar: &#039;[\\d\\.:\\ AMP]&#039;,
        date: &#039;^(?:(?:(?:(?:(?:(?:(?:(0?[13578]|1[02])(\\/|-|\\.)(31))\\2|(?:(0?[1,3-9]|1[0-2])(\\/|-|\\.)(29|30)\\5))|(?:(?:(?:(?:(31)(\\/|-|\\.)(0?[13578]|1[02])\\8)|(?:(29|30)(\\/|-|\\.)&#039; +
        &#039;(0?[1,3-9]|1[0-2])\\11)))))((?:1[6-9]|[2-9]\\d)?\\d{2})|(?:(?:(?:(0?2)(\\/|-|\\.)(29)\\15)|(?:(29)(\\/|-|\\.)(0?2))\\18)((?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])&#039; +
        &#039;|(?:(?:16|[2468][048]|[3579][26])00))))|(?:(?:((?:0?[1-9])|(?:1[0-2]))(\\/|-|\\.)(0?[1-9]|1\\d|2[0-8]))\\22|(0?[1-9]|1\\d|2[0-8])(\\/|-|\\.)((?:0?[1-9])|(?:1[0-2]))\\25)((?:1[6-9]|[2-9]\\d)?\\d{2}))))&#039; +
        &#039;|(?:(?:((?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(\\/|-|\\.)(?:(?:(?:(0?2)(?:\\29)(29))))|((?:1[6-9]|[2-9]\\d)?\\d{2})(\\/|-|\\.)&#039; +
        &#039;(?:(?:(?:(0?[13578]|1[02])\\33(31))|(?:(0?[1,3-9]|1[0-2])\\33(29|30)))|((?:0?[1-9])|(?:1[0-2]))\\33(0?[1-9]|1\\d|2[0-8]))))$&#039;,
        dateChar: &#039;[\\d\-\\.\\\]&#039;
    };

    events = [&#039;cellEditChange&#039;, &#039;beforeCellEdit&#039;, &#039;afterCellEdit&#039;, &#039;pageRequested&#039;, &#039;beforeDataBind&#039;, &#039;afterDataBind&#039;, &#039;columnReorder&#039;];

    aggregates = { count: &#039;Count: &#039;, average: &#039;Avg: &#039;, max: &#039;Max: &#039;, min: &#039;Min: &#039;, total: &#039;Total: &#039; };

    function formatTimeCellData(time, column, gridId) {
        var timeArray = getNumbersFromTime(time),
            formattedTime,
            format = storage.grids[gridId].columns[column].format,
            timeFormat = storage.grids[gridId].columns[column].timeFormat;

        if (timeArray.length &lt; 2) return &#039;&#039;;

        if (timeFormat &amp;&amp; timeFormat == &#039;24&#039; &amp;&amp; timeArray.length === 4 &amp;&amp; timeArray[3] === &#039;PM&#039;)
            timeArray[0] = timeArray[0] === 12 ? 0 : (timeArray[0] + 12);
        else if (timeFormat &amp;&amp; timeFormat === &#039;12&#039; &amp;&amp; timeArray[0] &gt; 12) {
            timeArray[0] = (timeArray[0] - 12);
            timeArray[3] = &#039;PM&#039;;
        }
        else if (timeFormat &amp;&amp; timeFormat === &#039;12&#039; &amp;&amp; timeArray.length &lt; 4)
            timeArray[3] = &#039;AM&#039;;

        timeArray[0] = timeArray[0] ? timeArray[0] : &#039;00&#039;;
        timeArray[1] = timeArray[1] ? timeArray[1] : &#039;00&#039;;
        timeArray[2] = timeArray[2] ? timeArray[2] : &#039;00&#039;;
        var meridiem = timeArray[3] || &#039;AM&#039;;

        if (timeArray.length &amp;&amp; format) {
            formattedTime = format.replace(&#039;hh&#039;, timeArray[0]).replace(&#039;mm&#039;, timeArray[1]).replace(&#039;ss&#039;, timeArray[2]).replace(&#039;A/PM&#039;, meridiem);
            return timeArray.length === 4 ? formattedTime + &#039; &#039; + timeArray[3] : formattedTime;
        }
        else if (timeArray.length) {
            formattedTime = timeArray[0] + &#039;:&#039; + timeArray[1] + &#039;:&#039; + timeArray[2] + &#039; &#039; + timeArray[3];
            return timeArray.length === 3 ? formattedTime + &#039; &#039; + timeArray[3] : formattedTime;
        }
        return &#039;&#039;;
    }

    function formatDateCellData(date, format) {
        if (!format) return date;
        var parseDate = Date.parse(date);
        var jsDate = new Date(parseDate);
        if (!isNaN(parseDate) &amp;&amp; format)
            return format.replace(&#039;mm&#039;, (jsDate.getUTCMonth() + 1).toString()).replace(&#039;dd&#039;, jsDate.getUTCDate().toString()).replace(&#039;yyyy&#039;, jsDate.getUTCFullYear().toString());
        else if (!isNaN(parseDate))
            return new Date(jsDate);
        return &#039;&#039;;
    }

    function formatNumericCellData(num, format) {
        if (!format) return num;
        var formatSections = [];
        var dataSections = [];
        var formatObject = (~format.indexOf(&#039;P&#039;) || ~format.indexOf(&#039;C&#039;)) ? createCurrencyOrPercentFormat(format) : verifyFormat(format);
        format = formatObject.value;

        var formatDecimalIndex = ~format.indexOf(&#039;.&#039;) ? format.indexOf(&#039;.&#039;) : format.length;
        formatSections[0] = format.substring(0, formatDecimalIndex).split(&#039;&#039;).reverse().join(&#039;&#039;);
        if (formatDecimalIndex &lt; format.length)
            formatSections[1] = format.substring(formatDecimalIndex + 1, format.length);

        var decimals = formatSections[1] ? formatSections[1].length : 0;

        if (formatObject.alterer)
            num = formatObject.alterer(+num);
        num = roundNumber(+num, decimals);
        var sign = 0 &gt; +num ? -1 : 1;
        num = num.toString();
        num = num.replace(new RegExp(&#039;,&#039;, &#039;g&#039;), &#039;&#039;).replace(&#039;-&#039;, &#039;&#039;);   
        var dataDecimalIndex = ~num.indexOf(&#039;.&#039;) ? num.indexOf(&#039;.&#039;) : num.length;
        dataSections[0] = num.substring(0, dataDecimalIndex).split(&#039;&#039;).reverse().join(&#039;&#039;);
        if (dataDecimalIndex &lt; format.length)
            dataSections[1] = num.substring(dataDecimalIndex + 1, num.length);
        else if (formatDecimalIndex &lt; format.length)
            dataSections[1] = &#039;&#039;;

        var wholeNums = [];
        var charsSinceComma = 0;
        if (formatSections[0].length) {
            var finalCharIndex, i;
            if (formatSections[0].length) {
                finalCharIndex = formatSections[0].length &gt; dataSections[0].length ? formatSections[0].length : dataSections[0].length;
                for (i = 0; i &lt; finalCharIndex; i++) {
                    if (formatObject.shouldInsertSeparators &amp;&amp; charsSinceComma === 3 &amp;&amp; (dataSections[0].charAt(i) || formatSections[0].charAt(i) === &#039;0&#039;)) {
                        wholeNums.push(&#039;,&#039;);
                        charsSinceComma = 0;
                    }
                    if (dataSections[0].charAt(i)) {
                        wholeNums.push(dataSections[0].charAt(i));
                        charsSinceComma++;
                    }
                    else if (formatSections[0].charAt(i) === &#039;0&#039;) {
                        wholeNums.push(&#039;0&#039;);
                        charsSinceComma++;
                    }
                    else break;
                }
            }
            wholeNums = wholeNums.reverse().join(&#039;&#039;);

            var fractionNums = [];
            if (formatSections.length &gt; 1) {
                finalCharIndex = formatSections[1].length &gt; dataSections[1].length ? formatSections[1].length : dataSections[1].length;
                for (i = 0; i &lt; finalCharIndex; i++) {
                    if (formatSections[1].charAt(i) &amp;&amp; dataSections[1].charAt(i))
                        fractionNums.push(dataSections[1].charAt(i));
                    else if (formatSections[1].charAt(i) === &#039;0&#039;)
                        fractionNums.push(&#039;0&#039;);
                    else break;
                }
            }
            fractionNums = fractionNums.join(&#039;&#039;);

            var value = fractionNums.length ? wholeNums + &#039;.&#039; + fractionNums : wholeNums;
            return sign === -1 ? formatObject.prependedSymbol + &#039;-&#039; + value + formatObject.appendedSymbol : formatObject.prependedSymbol + value + formatObject.appendedSymbol;
        }
        return num;
    }

    function verifyFormat(format) {
        var formatSections = [];
        format = format.replace(/[^0#,.]/g , &#039;&#039;);

        var decimalIndex = ~format.indexOf(&#039;.&#039;) ? format.indexOf(&#039;.&#039;) : format.length;
        var leadingChars = format.substring(0, decimalIndex);
        var shouldInsertSeparators = leadingChars.indexOf(&#039;,&#039;) &gt; -1;
        leadingChars = leadingChars.replace(new RegExp(&#039;,&#039;, &#039;g&#039;), &#039;&#039;);

        formatSections[0] = leadingChars;
        if (decimalIndex &lt; format.length)
            formatSections[1] = format.substring(decimalIndex + 1, format.length).split(&#039;&#039;).reverse().join(&#039;&#039;);

        for (var i = 0; i &lt; formatSections.length; i++) {
            var zeroFound = false;
            for (var j = 0; j &lt; formatSections[i].length; j++) {
                if (zeroFound &amp;&amp; formatSections[i].charAt(j) !== &#039;0&#039;)
                    formatSections[i] = formatSections[i].substring(0, j) + &#039;0&#039; + formatSections[i].substring(j + 1, formatSections[i].length);
                else if (!zeroFound &amp;&amp; formatSections[i].charAt(j) === &#039;0&#039;)
                    zeroFound = true;
            }
        }

        return {
            value: formatSections.length &lt; 2 ? formatSections[0] : formatSections[0] + &#039;.&#039; + formatSections[1].split(&#039;&#039;).reverse().join(&#039;&#039;),
            shouldInsertSeparators: shouldInsertSeparators,
            alterer: null,
            prependedSymbol: &#039;&#039;,
            appendedSymbol: &#039;&#039;
        };
    }

    function createCurrencyOrPercentFormat(format) {
        var charStripper = &#039;\\d{0,2}]&#039;,
            cOrP = ~format.indexOf(&#039;P&#039;) ? &#039;P&#039; : &#039;C&#039;;
        format = format.split(cOrP);
        var wholeNums = verifyFormat(format[0]),
            re = new RegExp(&#039;[^&#039; + cOrP + charStripper, &#039;g&#039;);
        format = format[1].replace(re, &#039;&#039;);
        var numDecimals = 2, newFormat;
        if (format.length)
            numDecimals = parseInt(format.substring(0,2));

        if (wholeNums.value)
            newFormat = numDecimals ? wholeNums.value + &#039;.&#039; : wholeNums.value;
        else if (numDecimals &amp;&amp; cOrP === &#039;C&#039;)
            newFormat = &#039;0.&#039;;
        else if (numDecimals &amp;&amp; cOrP === &#039;P&#039;)
            newFormat = &#039;00.&#039;;
        else newFormat = cOrP === &#039;C&#039; ? &#039;0&#039; : &#039;00&#039;;

        for (var i = 0; i &lt; numDecimals; i++) {
            newFormat += &#039;0&#039;;
        }
        return { value: newFormat,
            shouldInsertSeparators: wholeNums.shouldInsertSeparators,
            alterer: cOrP == &#039;C&#039; ? null : x100,
            prependedSymbol: cOrP === &#039;C&#039; ? &#039;$&#039; : &#039;&#039;,
            appendedSymbol: cOrP === &#039;P&#039; ? &#039;%&#039; : &#039;&#039;
        };
    }

    function x100(val) {
        return val * 100;
    }

    function roundNumber(val, dec) {
        var pow = Math.pow(10, dec || 0);
        return Math.round((val*pow))/pow;
    }

    function cloneGridData(gridData) { 
        if (gridData == null || typeof (gridData) !== &#039;object&#039;)
            return gridData;

        if (Object.prototype.toString.call(gridData) === &#039;[object Array]&#039;)
            return cloneArray(gridData);

        var temp = {};
        for (var key in gridData)
            temp[key] = cloneGridData(gridData[key]);

        return temp;
    }

    function cloneArray(arr) {
        var length = arr.length,
            newArr = new arr.constructor(length);

        if (length &amp;&amp; typeof arr[0] == &#039;string&#039; &amp;&amp; hasOwnProperty.call(arr, &#039;index&#039;)) {
            newArr.index = arr.index;
            newArr.input = arr.input;
        }

        var index = -1;
        while (++index &lt; length) {
            newArr[index] = cloneGridData(arr[index]);
        }
        return newArr;
    }

    function isDomElement(node) {
        return node &amp;&amp; node instanceof Element &amp;&amp; node instanceof Node &amp;&amp; typeof node.ownerDocument === &#039;object&#039;;
    }

    function isNumber(value) {
        return typeof value === &#039;number&#039; &amp;&amp; value === value;
    }

    storage = {
        gridCount: 1,
        grids: []
    };

    Object.defineProperty(
        storage,
        &#039;count&#039;,
        {
            get: function _getCount() {
                return this.gridCount++;
            }
        }
    );

    var gridApi = {};

    return Object.defineProperties(
        gridApi, {
            &#039;getGridInstance&#039;: {
                value: function getGridInstance(elem) {
                    elem = $(elem);
                    for (var i = 0; i &lt; storage.grids.length; i++) {
                        if (elem[0] === storage.grids[i].grid[0])
                            return storage.grids[i].grid[0].grid;
                    }
                },
                writable: false,
                configurable: false
            },
            &#039;createGrid&#039;: {
                get: function _createGrid() {
                    return create;
                }
            },
            &#039;addNewColumns&#039;: {
                get: function _addNewColumns() {
                    return addNewColumns;
                }
            }
        }
    );
})(jQuery);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
